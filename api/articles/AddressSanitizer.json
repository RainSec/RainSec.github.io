{"title":"AddressSanitizer 漏洞检测技术剖析","uid":"9830e1ecf0b844b9805cff1f477e18bc","slug":"AddressSanitizer","date":"2022-10-08T07:07:45.000Z","updated":"2023-04-12T02:36:51.327Z","comments":true,"path":"api/articles/AddressSanitizer.json","keywords":null,"cover":"https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20221015/sanitizers.5w0qyt2gbqg0.webp","content":"<h1 id=\"AddressSanitizer-漏洞检测技术剖析\"><a href=\"#AddressSanitizer-漏洞检测技术剖析\" class=\"headerlink\" title=\"AddressSanitizer 漏洞检测技术剖析\"></a>AddressSanitizer 漏洞检测技术剖析</h1><p>  类似AFL之类的Fuzzing技术不断强大的一个核心原因就是漏洞检测能力的不断增强，作为AFL这款经典工具的核心，ASAN的漏洞检测核心能力值得关注。</p>\n<h2 id=\"ASAN简介\"><a href=\"#ASAN简介\" class=\"headerlink\" title=\"ASAN简介\"></a>ASAN简介</h2><p>  ASAN其实本身是作为LLVM项目的一部分存在于Clang里面，其作用就是一个强大的内存错误检测器，它由一个编译插桩模块和一个运行时库组成，据官网介绍其可以检测以下类型的漏洞：</p>\n<ol>\n<li>Out-of-bounds accesses to heap, stack and globals.</li>\n<li>Use-after-free</li>\n<li>Use-after-return</li>\n<li>Use-after-scpe</li>\n<li>Double-free, invalid free</li>\n<li>Memory leaks (experimental)</li>\n<li>initialization order checking</li>\n</ol>\n<p>  ASAN的使用方法非常简单，在进行clang编译的时候加上-fsanitize=address参数，这样ASAN的run time library就会被链接到可执行文件里面，但是ASAN并不支持对于共享库的链接。显而易见的是使用ASAN会导致性能降低，因此需要配合clang的一些优化参数，关于这一部分本文只做简单的使用示范不追究其原理，因为作者在性能优化这块就是个彩笔。<br>ASAN官方Demo：</p>\n<pre class=\"line-numbers language-C\" data-language=\"C\"><code class=\"language-C\">int main(int argc, char **argv) {\n  int *array = new int[100];\n  delete [] array;\n  return array[argc];  // BOOM\n}\n// clang++ -O1 -g -fsanitize=address -fno-omit-frame-pointer example_UseAfterFree.cc<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>如果ASAN检测到一个bug之后就会把相关的信息打印出来，同时ASAN也会直接退出，这是因为：</p>\n<ol>\n<li>这使得ASAN在编译插桩阶段产生更小更快的代码。</li>\n<li>一旦产生内存异常，程序就会进入inconsistent state（大致意思就是跟原来程序员预想的状态不同），这就会导致如果不终止ASAN就可能其在接下来的运行中产生误报。</li>\n</ol>\n<p>这就是ASAN的基本用法了，关于使用可以看参考链接。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>以下漏洞检测中，如果是简单常用的漏洞类型就不针对漏洞原理进行介绍，可以自行查找资料。</p></blockquote>\n<h2 id=\"ASAN算法\"><a href=\"#ASAN算法\" class=\"headerlink\" title=\"ASAN算法\"></a>ASAN算法</h2><p>  ASAN主要是检测内存，所以其算法也主要是对内存操作，因此对于ASAN来说，其第一步要做的就是接管目标的内存管理。ASAN的具体做法是通过runtime library替代原有的malloc和free，同时将malloc分配的内存周围的区域标记为red-zones（red-zones内存状态被称为为（poisoned）中毒状态），同时将free掉的内存单独隔离并标记为中毒状态，并且每一次程序访问内存的操作都会被修改为如下：<br>编译前：</p>\n<pre class=\"line-numbers language-C\" data-language=\"C\"><code class=\"language-C\">*address = ...;  // or: ... = *address;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>编译后：</p>\n<pre class=\"line-numbers language-C\" data-language=\"C\"><code class=\"language-C\">if (IsPoisoned(address)) {\n  ReportError(address, kAccessSize, kIsWrite);\n}\n*address = ...;  // or: ... = *address;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>那么此时会存在一些问题：</p>\n<ul>\n<li>如何快速实现IsPoisoned？</li>\n<li>如何更好的输出错误？</li>\n<li>所有的内存访问都应该被检查吗？（本文核心关注点）</li>\n</ul>\n<p>ASAN官方专门回答了第三个问题，根据官方的解释，ASAN不应该插桩所有的内存访问，因为在程序的运行过程当中需要大量访问相同位置的内存，如下：</p>\n<pre class=\"line-numbers language-C\" data-language=\"C\"><code class=\"language-C\">void inc(int *a) {\n  (*a)++;\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>此时同时存在对同一个地址的访问和存储操作，事实上对于内存访问错误，只用检测其中的一次操作就够了，而像下面的代码逻辑：</p>\n<pre class=\"line-numbers language-C\" data-language=\"C\"><code class=\"language-C\">if (...)\n  *a = ...\n*a = ...<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>或者：</p>\n<pre class=\"line-numbers language-C\" data-language=\"C\"><code class=\"language-C\">*a = ...\nif (...)\n  *a = ...<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>  其实都是只用检测一次内存访问就够了，还有循环之类的操作，其实没必要对循环内的每一次内存访问全部都插桩处理，还有很多其它的优化情况比如变量的数据流传递过程中，没必要对未发生实际变量内存地址改变的情况下对每次一关于该变量的内存访问都做检查，又或者对于全局常量的内存访问检查很可能是没有意义的。根据官方解释，这些优化目前还没有完全应用到ASAN，有兴趣的可以自行探索一下。</p>\n<p>简单说一下ASAN的优化思路之后回到其内存管理，ASAN会将全部的虚拟内存分为两大部分：</p>\n<ol>\n<li>Main application memory：这块内存主要用于程序常规的内存分配。</li>\n<li>Shadow memory：该内存区域保存着一些元数据，假如Main mem里面的某一个bit的数据被标记为中毒状态，那么在对应的Shadow memory里面都有所记录。</li>\n</ol>\n<p>这两种内存相互配合，因此一旦Main mem里面有内存被标记，那么对应的Shadow memory应该被快速计算出来。</p>\n<pre class=\"line-numbers language-C\" data-language=\"C\"><code class=\"language-C\">shadow_address = MemToShadow(address);\nif (ShadowIsPoisoned(shadow_address)) {\n  ReportError(address, kAccessSize, kIsWrite);\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>上面代码的意思应该是不允许存在多次中毒标记同一地址。</p>\n<p>Main mem和Shadow memory之间的映射关系是8字节的Main mem对应1字节的Shadow memory，这一点应该很好理解，存在这样一种机制的核心作用还是确定那些内存是可访问的，那些内存是不可访问的，关于具体的映射细节可以看<a href=\"https://github.com/google/sanitizers/wiki/AddressSanitizerAlgorithm#mapping\">这里</a>，非常简单。</p>\n<p>接下来介绍，ASAN是如何报告错误的。</p>\n<ul>\n<li>复制内存异常地址到rax(eax)</li>\n<li>execute ud2 (generates SIGILL) SIGILL是一个signal信号，当处理器遇到非法指令的时候就会发出该信号。该信号中断进程并进行core dump。</li>\n</ul>\n<p>  用一个字节编码异常地址访问类型和大小，全部的三个步骤大概需要5-6字节的机器码。<br>通过上述内容已经基本了解堆内存的管理办法，那么栈内存该如何处理呢？<br>Demo：</p>\n<pre class=\"line-numbers language-C\" data-language=\"C\"><code class=\"language-C\">void foo() {\n  char a[8];\n  ...\n  return;\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>编译插桩后：</p>\n<pre class=\"line-numbers language-C\" data-language=\"C\"><code class=\"language-C\">void foo() {\n  char redzone1[32];  // 32-byte aligned\n  char a[8];          // 32-byte aligned\n  char redzone2[24];\n  char redzone3[32];  // 32-byte aligned\n  int  *shadow_base = MemToShadow(redzone1);\n  shadow_base[0] = 0xffffffff;  // poison redzone1\n  shadow_base[1] = 0xffffff00;  // poison redzone2, unpoison 'a'\n  shadow_base[2] = 0xffffffff;  // poison redzone3\n  ...\n  shadow_base[0] = shadow_base[1] = shadow_base[2] = 0; // unpoison all\n  return;\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>  其处理办法也是类似的，将程序中分配的栈空间周围内存进行标记来观察接下来的代码访问过程中是否会存在内存越界操作。<br>  在整个漏洞检测中除了内存监控算法之外，还有一个比较重要的就是call stack算法，关于call stack，ASAN主要收集以下三个事件相关的stack：</p>\n<ol>\n<li>malloc and free</li>\n<li>Thread create</li>\n<li>Failure</li>\n</ol>\n<p> 对于ASAN来说，其收集stack trace相关的信息是利用了LLVM项目里面的另一个工具llvm-symbolizer，llvm-symboilzer的作用是从命令行接收目标文件名和地址，然后打印地址对应的源码位置到标准输出。ASAN利用llvm-symboilzer可以将地址全部符号化，从而实现对stack trace的符号化记录，因此在report error的时候就可以看到更多详细信息。</p>\n<p>到此关于ASAN中内存相关的基础算法介绍结束，下面主要剖析具体漏洞类型的检测。</p>\n<h2 id=\"漏洞检测\"><a href=\"#漏洞检测\" class=\"headerlink\" title=\"漏洞检测\"></a>漏洞检测</h2><h3 id=\"OOB\"><a href=\"#OOB\" class=\"headerlink\" title=\"OOB\"></a>OOB</h3><p>  通过对上述算法的了解我们就能知道OOB的检测来源于ASAN中的red zones算法。</p>\n<h3 id=\"UAF\"><a href=\"#UAF\" class=\"headerlink\" title=\"UAF\"></a>UAF</h3><p>  其实在上面的基本算法介绍完了之后就应该明白其UAF的检测原理，每一次的free之后，ASAN并不会直接释放内存，而是对其进行标记和隔离，那么下一次对释放内存进行访问时就可以被监视到，然后输出错误报告。</p>\n<h3 id=\"UAR\"><a href=\"#UAR\" class=\"headerlink\" title=\"UAR\"></a>UAR</h3><p>  默认条件下ASAN并不检测这个bug，这种类型的漏洞其实也很少被提及，可能是利用条件比较苛刻的原因（个人猜测），可以看下官方demo：</p>\n<pre class=\"line-numbers language-C\" data-language=\"C\"><code class=\"language-C\">// RUN: clang -O -g -fsanitize=address %t &amp;&amp; ./a.out\n// By default, AddressSanitizer does not try to detect\n// stack-use-after-return bugs.\n// It may still find such bugs occasionally\n// and report them as a hard-to-explain stack-buffer-overflow.\n\n// You need to run the test with ASAN_OPTIONS=detect_stack_use_after_return=1\n\nint *ptr;\n__attribute__((noinline))\nvoid FunctionThatEscapesLocalObject() {\n  int local[100];\n  ptr = &amp;local[0];\n}\n\nint main(int argc, char **argv) {\n  FunctionThatEscapesLocalObject();\n  return ptr[argc];\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>  对于这种漏洞的检测，ASAN其实采用的也是类似heap uaf的做法，但是在具体的实现方法上存在的差别还是很大的。对于栈帧比较了解的人应该清楚，一旦一个函数return，那么它的栈就会被回收然后在下一次栈分配的时候被重复利用，如此来看通过red-zones类似的方法显然是行不通的，ASAN的做法是将栈迁移到堆上：<br>未迁移前：</p>\n<pre class=\"line-numbers language-C\" data-language=\"C\"><code class=\"language-C\">void foo() {\n  int local;\n  escape_addr(&amp;local);\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>迁移后：</p>\n<pre class=\"line-numbers language-C\" data-language=\"C\"><code class=\"language-C\">void foo() {\n  char redzone1[32];\n  int local;\n  char redzone2[32+28];\n  char *fake_stack = __asan_stack_malloc(&amp;local, 96);\n  poison_redzones(fake_stack);  // Done by the inlined instrumentation code.\n  escape_addr(fake_stack + 32);\n  __asan_stack_free(stack, &amp;local, 96)\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>  __asan_stack_malloc(real_stack, frame_size)函数会从fake stack（ASAN实现的一个thread-local heap-like structure）分配一个大小为framz_size的fake frame，所有的fake frame都来自未被标记为中毒状态的内存，但是如果被使用（如上demo）就会被poison_redzones标记。__asan_stack_free(fake_stack, real_stack, frame_size)函数则会将所有的fake frame标记为中毒状态并进行释放。那么如果存在UAR的时候会因访问被标记为中毒的内存而被检测出异常。<br>  从上面可以看出这种检测方法还是挺消耗内存的，fake stack 分配器会为每个线程分配固定大小的内存，大小从2的6次方到2的16次方字节不等，每个线程对应的内存也会被分成一定数量的chunk，如果chunk被用完，那么接下来的栈分配就会使用程序原本的stack，此时的UAR检测也会实效，因此越好的检测效果就代表越高的内存消耗。</p>\n<h3 id=\"UAS\"><a href=\"#UAS\" class=\"headerlink\" title=\"UAS\"></a>UAS</h3><p>UAS同样知名度不高，先看官方Demo：</p>\n<pre class=\"line-numbers language-C\" data-language=\"C\"><code class=\"language-C\">// RUN: clang -O -g -fsanitize=address -fsanitize-address-use-after-scope \\\n//    use-after-scope.cpp -o /tmp/use-after-scope\n// RUN: /tmp/use-after-scope\n\n// Check can be disabled in run-time:\n// RUN: ASAN_OPTIONS=detect_stack_use_after_scope=0 /tmp/use-after-scope\n\nvolatile int *p = 0;\n\nint main() {\n  {\n    int x = 0;\n    p = &amp;x;\n  }\n  *p = 5;\n  return 0;\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>  大致意思就是作用域内定义的变量在作用域外被访问，ASAN检测这种漏洞的办法是随着程序的执行流不断的标记被局部变量使用的内存，当执行流到达一个作用域的时候，相关局部变量的内存被标记为good，当执行流到达一个作用域的结尾时，相关内存被标记为bad，看下面的demo：<br>编译前：</p>\n<pre class=\"line-numbers language-C\" data-language=\"C\"><code class=\"language-C\">void f() {\n  int *p;\n  if (b) {\n    int x[10];\n    p = x;\n  }\n  *p = 1;\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>编译后：</p>\n<pre class=\"line-numbers language-C\" data-language=\"C\"><code class=\"language-C\">void f() {\n  int *p;\n  if (b) {\n    __asan_unpoison_stack_memory(x);\n    int x[10];\n    p = x;\n    __asan_poison_stack_memory(x);\n  }\n  *p = 1;\n   __asan_unpoison_stack_memory(frame);\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>因为栈是会被复用的，所以在函数return之前必须将相关内存取消中毒标记。</p>\n<h3 id=\"Double-free-and-invalid-free\"><a href=\"#Double-free-and-invalid-free\" class=\"headerlink\" title=\"Double free and invalid free\"></a>Double free and invalid free</h3><p>参考UAF。</p>\n<h3 id=\"Memory-leaks-experimental\"><a href=\"#Memory-leaks-experimental\" class=\"headerlink\" title=\"Memory leaks (experimental)\"></a>Memory leaks (experimental)</h3><p>  试验级别的先不说，ASAN专门集成了LeakSanitizer来研究这类漏洞的检测，可以参考<a href=\"https://github.com/google/sanitizers/wiki/AddressSanitizerLeakSanitizer\">这里</a>。</p>\n<h3 id=\"initialization-order-checking\"><a href=\"#initialization-order-checking\" class=\"headerlink\" title=\"initialization order checking\"></a>initialization order checking</h3><p>Static initialization order fiasco，这在C++程序静态全局变量初始化过程中很常见。但是这种漏洞其实比较难以检测，因为C++静态全局变量的初始化出现在Main函数执行之前。至于漏洞模型，其实也很简单，假设在A.cpp和B.cpp里面分别存在两个全局静态类C和D，假设D在初始化过程中依赖C中的某些方法但是D初始化在C之前，那么就可能会导致crash。<br>官方demo：</p>\n<pre class=\"line-numbers language-C\" data-language=\"C\"><code class=\"language-C\">$ cat tmp/init-order/example/a.cc\n#include &lt;stdio.h&gt;\nextern int extern_global;\nint __attribute__((noinline)) read_extern_global() {\n  return extern_global;\n}\nint x = read_extern_global() + 1;\nint main() {\n  printf(\"%d\\n\", x);\n  return 0;\n}\n\n$ cat tmp/init-order/example/b.cc\nint foo() { return 42; }\nint extern_global = foo();<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>官方demo表明假如foo先初始化，那么就会输出43，否则就会输出1，间接表明了初始化顺序可能导致的一些安全问题。<br>ASAN对于这里漏洞的扫描默认是关闭的，可以参考<a href=\"https://github.com/google/sanitizers/wiki/AddressSanitizerFlags\">这里</a>开启，它的检测方式分为很多种：</p>\n<h3 id=\"Loose-init-order-checking\"><a href=\"#Loose-init-order-checking\" class=\"headerlink\" title=\"Loose init-order checking\"></a>Loose init-order checking</h3><p>  ASAN的这个检测方式很简单，就是在一个全局变量初始化过程中访问另一个全局变量之前检测要访问的全局变量是否已经完成初始化，但是很明显，这种动态检测在上述demo输出43的时候不会报告错误。</p>\n<h3 id=\"Strict-init-order-checking\"><a href=\"#Strict-init-order-checking\" class=\"headerlink\" title=\"Strict init-order checking\"></a>Strict init-order checking</h3><p>  这个只是相对于Loose init-order checking更为严格了，只要进行访问就报告错误，这虽然能发现潜在的错误，但是也可能会触发误报。所以其实这两种方法各有千秋。为了解决这些问题，ASAN的此类漏洞扫描存在黑名单机制，把不想扫描的全局变量可以加入Blacklist来防止误报，但是可能会让漏洞研究人员多花点心思。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><a href=\"https://clang.llvm.org/docs/AddressSanitizer.html\">https://clang.llvm.org/docs/AddressSanitizer.html</a><br><a href=\"https://github.com/google/sanitizers/wiki/AddressSanitizer\">https://github.com/google/sanitizers/wiki/AddressSanitizer</a><br><a href=\"https://isocpp.org/wiki/faq/ctors#static-init-order\">https://isocpp.org/wiki/faq/ctors#static-init-order</a></p></blockquote>\n","text":"AddressSanitizer 漏洞检测技术剖析 类似AFL之类的Fuzzing技术不断强大的一个核心原因就是漏洞检测能力的不断增强，作为AFL这款经典工具的核心，ASAN的漏洞检测核心能力值得关注...","link":"","photos":[],"count_time":{"symbolsCount":"7.4k","symbolsTime":"7 mins."},"categories":[{"name":"漏洞挖掘","slug":"漏洞挖掘","count":6,"path":"api/categories/漏洞挖掘.json"}],"tags":[{"name":"漏洞挖掘","slug":"漏洞挖掘","count":2,"path":"api/tags/漏洞挖掘.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#AddressSanitizer-%E6%BC%8F%E6%B4%9E%E6%A3%80%E6%B5%8B%E6%8A%80%E6%9C%AF%E5%89%96%E6%9E%90\"><span class=\"toc-text\">AddressSanitizer 漏洞检测技术剖析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ASAN%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">ASAN简介</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ASAN%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">ASAN算法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%BC%8F%E6%B4%9E%E6%A3%80%E6%B5%8B\"><span class=\"toc-text\">漏洞检测</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#OOB\"><span class=\"toc-text\">OOB</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#UAF\"><span class=\"toc-text\">UAF</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#UAR\"><span class=\"toc-text\">UAR</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#UAS\"><span class=\"toc-text\">UAS</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Double-free-and-invalid-free\"><span class=\"toc-text\">Double free and invalid free</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Memory-leaks-experimental\"><span class=\"toc-text\">Memory leaks (experimental)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#initialization-order-checking\"><span class=\"toc-text\">initialization order checking</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Loose-init-order-checking\"><span class=\"toc-text\">Loose init-order checking</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Strict-init-order-checking\"><span class=\"toc-text\">Strict init-order checking</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">参考链接</span></a></li></ol></li></ol>","author":{"name":"RainSec","slug":"blog-author","avatar":"https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20220714/logo.jpg","link":"/","description":"艺术家思维去思考问题，工匠创造精神去开发","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"对Xray 5.6W条结果的简单分析","uid":"7865cd0898eb778742478bf73fa460c6","slug":"Xray数据分析","date":"2022-10-12T11:48:45.000Z","updated":"2023-04-12T02:36:51.351Z","comments":true,"path":"api/articles/Xray数据分析.json","keywords":null,"cover":"https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20221012/image-20221009230905837.2jiiuh6lk5s0.png","text":"对Xray 5.6W条结果的简单分析 前言自动化扫描src已经做一段时间了，各类问题累计扫出来7.3w+，其中xray作为扫描漏洞的主力之一，上报了5.6w+问题 。目前应该是全网使用xray漏洞记录...","link":"","photos":[],"count_time":{"symbolsCount":"3.3k","symbolsTime":"3 mins."},"categories":[{"name":"渗透测试","slug":"渗透测试","count":10,"path":"api/categories/渗透测试.json"}],"tags":[],"author":{"name":"RainSec","slug":"blog-author","avatar":"https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20220714/logo.jpg","link":"/","description":"艺术家思维去思考问题，工匠创造精神去开发","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Goby指纹与POC提取复现","uid":"84026449195101da50b0cdf96b2a3940","slug":"Goby指纹和POC提取","date":"2022-09-30T02:48:45.000Z","updated":"2023-04-12T02:36:51.371Z","comments":true,"path":"api/articles/Goby指纹和POC提取.json","keywords":null,"cover":"https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20220930/image.x02df1872g.webp","text":"Goby指纹与POC提取复现最近看了w8ay师傅发的关于提取Goby指纹的帖子，发现自己加入师傅的知识星球却一直没认真学习过实在是难顶嗷，根据师傅的帖子来复现自己提取一下，补上第一期的作业。 Goby...","link":"","photos":[],"count_time":{"symbolsCount":"5.7k","symbolsTime":"5 mins."},"categories":[{"name":"渗透测试","slug":"渗透测试","count":10,"path":"api/categories/渗透测试.json"}],"tags":[{"name":"渗透测试","slug":"渗透测试","count":3,"path":"api/tags/渗透测试.json"}],"author":{"name":"RainSec","slug":"blog-author","avatar":"https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20220714/logo.jpg","link":"/","description":"艺术家思维去思考问题，工匠创造精神去开发","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}