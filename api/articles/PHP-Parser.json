{"title":"PHP-Parser的基本使用","uid":"1c56be85ceb7e858a4dda415a10ab942","slug":"PHP-Parser","date":"2022-01-28T10:38:45.000Z","updated":"2023-09-29T03:48:35.105Z","comments":true,"path":"api/articles/PHP-Parser.json","keywords":null,"cover":"https://jsd.cdn.zzko.cn/gh/L2ksy0d/image-host@master/20220720/parsercover.png","content":"<h1 id=\"PHP-Parser\"><a href=\"#PHP-Parser\" class=\"headerlink\" title=\"PHP-Parser\"></a>PHP-Parser</h1><p>PHP-Parser组件的基础使用，该组件为静态分析和反混淆常用的第三方依赖。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"What-is-PHP-Parser\"><a href=\"#What-is-PHP-Parser\" class=\"headerlink\" title=\"What is PHP-Parser\"></a>What is PHP-Parser</h2><p><code>PHP-Parser</code>是<code>nikic</code>用PHP编写的PHP5.2到PHP7.4解析器，其目的是简化静态代码分析和操作</p>\n<h2 id=\"PHP-Parser的基础使用\"><a href=\"#PHP-Parser的基础使用\" class=\"headerlink\" title=\"PHP-Parser的基础使用\"></a>PHP-Parser的基础使用</h2><p>这里先贴一下官方文档</p>\n<p><a href=\"https://github.com/nikic/PHP-Parser/tree/master/doc\">PHP-Parser/doc at master · nikic/PHP-Parser (github.com)</a></p>\n<p>最基本的是要理解其中<a href=\"https://github.com/nikic/PHP-Parser/blob/master/doc/component/Walking_the_AST.markdown\">Walking the AST</a>的部分</p>\n<h2 id=\"初始化解析器\"><a href=\"#初始化解析器\" class=\"headerlink\" title=\"初始化解析器\"></a>初始化解析器</h2><p>首先创建实例</p>\n<pre class=\"line-numbers language-php\" data-language=\"php\"><code class=\"language-php\"><span class=\"token keyword\">use</span> <span class=\"token package\">PhpParser<span class=\"token punctuation\">\\</span>ParserFactory</span><span class=\"token punctuation\">;</span>\n<span class=\"token variable\">$parser</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">ParserFactory</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-&gt;</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span><span class=\"token class-name static-context\">ParserFactory</span><span class=\"token operator\">::</span><span class=\"token constant\">PREFER_PHP7</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>这其中有以下参数</p>\n<p>KindBehaviorParserFactory::PREFER_PHP7Try to parse code as PHP 7. If this fails, try to parse it as PHP 5.ParserFactory::PREFER_PHP5Try to parse code as PHP 5. If this fails, try to parse it as PHP 7.ParserFactory::ONLY_PHP7Parse code as PHP 7.ParserFactory::ONLY_PHP5Parse code as PHP 5.</p>\n<p>create还有一个参数Lexer，这里先不做讨论</p>\n<p>在实例化之后我们就可以通过</p>\n<pre class=\"line-numbers language-php\" data-language=\"php\"><code class=\"language-php\"><span class=\"token variable\">$stmts</span> <span class=\"token operator\">=</span> <span class=\"token variable\">$parser</span><span class=\"token operator\">-&gt;</span><span class=\"token function\">parse</span><span class=\"token punctuation\">(</span><span class=\"token variable\">$code</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>来将代码转换成AST</p>\n<p>为了防止抛出异常，最好在try….catch中执行</p>\n<h3 id=\"生成更加直观的AST\"><a href=\"#生成更加直观的AST\" class=\"headerlink\" title=\"生成更加直观的AST\"></a>生成更加直观的AST</h3><p>当我们var_dump上面的$stmt时，会得到一个比较乱的AST，可以使用NodeDump将其转化为更加直观的AST</p>\n<p>这里需要使用NodeDump</p>\n<p>对于代码</p>\n<pre class=\"line-numbers language-PHP\" data-language=\"PHP\"><code class=\"language-PHP\">&lt;?php\nfunction printLine($msg) {\n    echo $msg, \"\\n\";\n}\nprintLine('Hello World!!!');<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>将其转换为AST</p>\n<pre class=\"line-numbers language-PHP\" data-language=\"PHP\"><code class=\"language-PHP\">&lt;?php\nuse PhpParser\\NodeDumper;\n$nodeDumper = new NodeDumper;echo $nodeDumper-&gt;dump($stmts), \"\\n\";<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>得到以下输出</p>\n<pre class=\"line-numbers language-YAML\" data-language=\"YAML\"><code class=\"language-YAML\">array(\n    0: Stmt_Function(\n        byRef: false\n        name: Identifier(\n            name: printLine\n        )\n        params: array(\n            0: Param(\n                type: null\n                byRef: false\n                variadic: false\n                var: Expr_Variable(\n                    name: msg\n                )\n                default: null\n            )\n        )\n        returnType: null\n        stmts: array(\n            0: Stmt_Echo(\n                exprs: array(\n                    0: Expr_Variable(\n                        name: msg\n                    )\n                    1: Scalar_String(\n                        value:\n\n                    )\n                )\n            )\n        )\n    )\n    1: Stmt_Expression(\n        expr: Expr_FuncCall(\n            name: Name(\n                parts: array(\n                    0: printLine\n                )\n            )\n            args: array(\n                0: Arg(\n                    value: Scalar_String(\n                        value: Hello World!!!\n                    )\n                    byRef: false\n                    unpack: false\n                )\n            )\n        )\n    )\n)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"Node-tree-structure\"><a href=\"#Node-tree-structure\" class=\"headerlink\" title=\"Node tree structure\"></a>Node tree structure</h3><p>上面我们可以看到生成了很多的Node类型</p>\n<p>PHP是一个成熟的脚本语言，它大约有140个不同的节点。但是为了方便使用，将他们分为三类：</p>\n<ul>\n<li><p><code>PhpParser\\Node\\Stmts</code>是语句节点，即不返回值且不能出现在表达式中的语言构造。例如，类定义是一个语句，它不返回值，你不能编写类似func(class {})的语句。</p>\n</li>\n<li><p><code>PhpParser\\Node\\expr</code>是表达式节点，即返回值的语言构造，因此可以出现在其他表达式中。如：<code>$var (PhpParser\\Node\\Expr\\Variable)</code>和<code>func() (PhpParser\\Node\\Expr\\FuncCall)</code>。</p>\n</li>\n<li><p><code>PhpParser\\Node\\Scalars</code>是表示标量值的节点，如<code>\"string\" (PhpParser\\Node\\scalar\\string)</code>、<code>0 (PhpParser\\Node\\scalar\\LNumber)</code> 或魔术常量，如”<strong>FILE</strong>“ <code>(PhpParser\\Node\\scalar\\MagicConst\\FILE)</code> 。所有<code>PhpParser\\Node\\scalar</code>都是延伸自<code>PhpParser\\Node\\Expr</code>，因为scalar也是表达式。</p>\n</li>\n<li><p>需要注意的是<code>PhpParser\\Node\\Name</code>和<code>PhpParser\\Node\\Arg</code>不在以上的节点之中</p>\n</li>\n</ul>\n<h3 id=\"Pretty-printer\"><a href=\"#Pretty-printer\" class=\"headerlink\" title=\"Pretty printer\"></a>Pretty printer</h3><p>Prettyprinter用来将我们修改后的AST转换回PHP代码，使用如下</p>\n<pre class=\"line-numbers language-php\" data-language=\"php\"><code class=\"language-php\">use PhpParser\\Error;\nuse PhpParser\\ParserFactory;\nuse PhpParser\\PrettyPrinter;\n$code = \"<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>?php</span> <span class=\"token attr-name\">echo</span> <span class=\"token attr-name\">'Hi</span> <span class=\"token attr-name\">',</span> <span class=\"token attr-name\">hi\\\\getTarget();\";</span>\n<span class=\"token attr-name\">$parser</span> <span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span> (new</span> <span class=\"token attr-name\">ParserFactory)-</span><span class=\"token punctuation\">&gt;</span></span>create(ParserFactory::PREFER_PHP7);$prettyPrinter = new PrettyPrinter\\Standard;\ntry {\n    //生成AST\n    $stmts = $parser-&gt;parse($code);\n    //对节点进行操作\n    $stmts[0]         // the echo statement\n          -&gt;exprs     // sub expressions\n          [0]         // the first of them (the string node)\n          -&gt;value     // it's value, i.e. 'Hi '\n          = 'Hello '; // change to 'Hello '\n\n    // pretty print\n    $code = $prettyPrinter-&gt;prettyPrint($stmts);\n    echo $code;\n} catch (Error $e) {\n    echo 'Parse Error: ', $e-&gt;getMessage();\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>在反混淆中我们一般很少使用$stmts[0]这种方式，因为我们要考虑节点的各种类型</p>\n<p>此外还有prettyPrintExpr()，它可以用来输出一个表达式类型的节点</p>\n<p>例如当你需要提取全局变量时</p>\n<pre class=\"line-numbers language-PHP\" data-language=\"PHP\"><code class=\"language-PHP\">&lt;?php\n    $a = $_POST['a'];<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>他的语法树如下</p>\n<pre class=\"line-numbers language-YAML\" data-language=\"YAML\"><code class=\"language-YAML\">0: Stmt_Expression(\n        expr: Expr_Assign(\n            var: Expr_Variable(\n                name: a\n            )\n            expr: Expr_ArrayDimFetch(\n                var: Expr_Variable(\n                    name: _POST\n                )\n                dim: Scalar_String(\n                    value: a\n                )\n            )\n        )\n    )<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>如果我想获取$_POST[‘a’],我就需要先判断节点类型是不是<code>Expr_ArrayDimFetch</code></p>\n<p>然后判断<code>$node-&gt;var-&gt;name</code>是不是全局变量</p>\n<p>最后提取<code>$node-&gt;var-&gt;name</code>和<code>$node-&gt;dim-&gt;value</code>然后将它们拼接</p>\n<p>当我的全局变量为<code>$_POST[a]</code>时，dim部分的AST也会变化，我们还需要考虑这种情况。</p>\n<p>但是我们可以使用</p>\n<pre class=\"line-numbers language-PHP\" data-language=\"PHP\"><code class=\"language-PHP\">/*\n    用来识别全局变量;\n    如果要获取全局变量格式无需考虑value的节点类型\n    expr: Expr_ArrayDimFetch(\n            var: Expr_Variable(\n                name: _POST\n            )\n    )\n*/\n        if ($node instanceof Node\\Expr\\ArrayDimFetch &amp;&amp; $node-&gt;var instanceof Node\\Expr\\Variable &amp;&amp; (in_array($node-&gt;var-&gt;name ,GLOBAL_VAR)))\n        {\n            self::$globalname = $this-&gt;prettyPrinter-&gt;prettyPrintExpr($node);\n        }<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>其中</p>\n<pre class=\"line-numbers language-PHP\" data-language=\"PHP\"><code class=\"language-PHP\">$this-&gt;prettyPrinter-&gt;prettyPrintExpr($node);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>就会返回该Expr节点的表达式，无论是<code>$_POST['a']</code>还是<code>$_POST[a]</code>都可以正常返回</p>\n<p><a href=\"https://github.com/nikic/PHP-Parser/blob/master/doc/component/Pretty_printing.markdown\">PHP-Parser/Pretty_printing.markdown at master · nikic/PHP-Parser (github.com)</a></p>\n<h2 id=\"Node-traversation\"><a href=\"#Node-traversation\" class=\"headerlink\" title=\"Node traversation\"></a>Node traversation</h2><p>我们使用PHP-Parser对文件的节点进行修改，最关键的就是编写节点遍历操作</p>\n<p>使用<code>PhpParser\\NodeTraverser</code>我们可以遍历每一个节点，举几个简单的例子：解析php中的所有字符串，并输出</p>\n<pre class=\"line-numbers language-PHP\" data-language=\"PHP\"><code class=\"language-PHP\">&lt;?php\nuse PhpParser\\Error;\nuse PhpParser\\ParserFactory;\nuse PhpParser\\NodeTraverser;\nuse PhpParser\\NodeVisitorAbstract;\nuse PhpParser\\Node;\n\nrequire 'vendor/autoload.php';\n\nclass MyVisitor extends NodeVisitorAbstract{\n    public function leaveNode(Node $node)\n    {\n        //判断如果是一个String_节点，就输出\n        if ($node instanceof Node\\Scalar\\String_)\n        {\n            echo $node -&gt; value,\"\\n\";\n        }\n\n    }\n}\n\n$code = file_get_contents(\"./test.php\");\n\n//实例化解释器\n$parser = (new ParserFactory)-&gt;create(ParserFactory::PREFER_PHP7);\n$traverser = New NodeTraverser;\n//添加自己的Visitor\n$traverser-&gt;addVisitor(new MyVisitor);\n\ntry {\n    //转化AST\n    $ast = $parser-&gt;parse($code);\n    //开始遍历\n    $stmts = $traverser-&gt;traverse($ast);\n} catch (Error $error) {\n    echo \"Parse error: {$error-&gt;getMessage()}\\n\";\n    return;\n}\n\n?&gt;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>替换php脚本中函数以及类的成员方法函数名为小写</p>\n<pre class=\"line-numbers language-PHP\" data-language=\"PHP\"><code class=\"language-PHP\">class MyVisitor extends NodeVisitorAbstract{\n    public function leaveNode(Node $node)\n    {\n        if( $node instanceof Node\\Expr\\FuncCall) {\n            $node-&gt;name-&gt;parts[0]=strtolower($node-&gt;name-&gt;parts[0]);\n        }elseif($node instanceof Node\\Stmt\\ClassMethod){\n            $node-&gt;name-&gt;name=strtolower($node-&gt;name-&gt;name);\n        }elseif ($node instanceof Node\\Stmt\\Function_){\n            $node-&gt;name-&gt;name=strtolower($node-&gt;name-&gt;name);\n        }elseif($node instanceof Node\\Expr\\MethodCall){\n            $node-&gt;name-&gt;name=strtolower($node-&gt;name-&gt;name);\n        }\n    }\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>需要注意的是所有的<code>visitors</code>都必须实现<code>PhpParser\\NodeVisitor</code>接口，该接口定义了如下4个方法：</p>\n<pre class=\"line-numbers language-PHP\" data-language=\"PHP\"><code class=\"language-PHP\">public function beforeTraverse(array $nodes);\npublic function enterNode(\\PhpParser\\Node $node);\npublic function leaveNode(\\PhpParser\\Node $node);\npublic function afterTraverse(array $nodes);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li><p><code>beforeTraverse</code>方法在遍历开始之前调用一次，并将其传递给调用遍历器的节点。此方法可用于在遍历之前重置值或准备遍历树。</p>\n</li>\n<li><p><code>afterTraverse</code>方法与<code>beforeTraverse</code>方法类似，唯一的区别是它只在遍历之后调用一次。</p>\n</li>\n<li><p>在每个节点上都调用<code>enterNode</code>和<code>leaveNode</code>方法，前者在它被输入时，即在它的子节点被遍历之前，后者在它被离开时。</p>\n</li>\n<li><p>这四个方法要么返回更改的节点，要么根本不返回(即null)，在这种情况下，当前节点不更改。</p>\n</li>\n</ul>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p><a href=\"http://j0k3r.top/2020/03/24/php-Deobfuscator/#0x01-php-parser\">基于 AST（抽象语法树）解 PHP 混淆 | J0k3r’s Blog</a></p>\n<h2 id=\"P-S\"><a href=\"#P-S\" class=\"headerlink\" title=\"P.S.\"></a>P.S.</h2><p>我们需要知道你需要什么样的Node，进行什么样的操作，Node下数据的格式会有哪几种情况，会不会因为代码不够严谨导致错误或者无限递归</p>\n","text":"PHP-ParserPHP-Parser组件的基础使用，该组件为静态分析和反混淆常用的第三方依赖。 What is PHP-ParserPHP-Parser是nikic用PHP编写的PHP5.2到PH...","link":"","photos":[],"count_time":{"symbolsCount":"7.1k","symbolsTime":"6 mins."},"categories":[{"name":"漏洞挖掘","slug":"漏洞挖掘","count":6,"path":"api/categories/漏洞挖掘.json"}],"tags":[{"name":"PHP","slug":"PHP","count":1,"path":"api/tags/PHP.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#PHP-Parser\"><span class=\"toc-text\">PHP-Parser</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#What-is-PHP-Parser\"><span class=\"toc-text\">What is PHP-Parser</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#PHP-Parser%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">PHP-Parser的基础使用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%9D%E5%A7%8B%E5%8C%96%E8%A7%A3%E6%9E%90%E5%99%A8\"><span class=\"toc-text\">初始化解析器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%94%9F%E6%88%90%E6%9B%B4%E5%8A%A0%E7%9B%B4%E8%A7%82%E7%9A%84AST\"><span class=\"toc-text\">生成更加直观的AST</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Node-tree-structure\"><span class=\"toc-text\">Node tree structure</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Pretty-printer\"><span class=\"toc-text\">Pretty printer</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Node-traversation\"><span class=\"toc-text\">Node traversation</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BE%8B%E5%AD%90\"><span class=\"toc-text\">例子</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#P-S\"><span class=\"toc-text\">P.S.</span></a></li></ol></li></ol>","author":{"name":"RainSec","slug":"blog-author","avatar":"https://jsd.cdn.zzko.cn/gh/L2ksy0d/image-host@master/20220714/logo.jpg","link":"/","description":"艺术家思维去思考问题，工匠创造精神去开发","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"RealWorld CTF之qiling框架分析","uid":"c240e7132c70272bfb31ce1eb51c281b","slug":"Qilin框架分析","date":"2022-01-28T10:48:45.000Z","updated":"2023-09-29T03:48:35.117Z","comments":true,"path":"api/articles/Qilin框架分析.json","keywords":null,"cover":"https://jsd.cdn.zzko.cn/gh/L2ksy0d/image-host@master/20220720/realworld.png","text":"RealWorld CTF之qiling框架分析qiling​当时题目就给了一个qiling的使用的用例，甚至和官方文档上面的用例差不多因此肯定是库的问题。 #!/usr/bin/env python...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[{"name":"CTF","slug":"CTF","count":2,"path":"api/categories/CTF.json"},{"name":"容器安全","slug":"CTF/容器安全","count":1,"path":"api/categories/CTF/容器安全.json"}],"tags":[{"name":"CTF","slug":"CTF","count":2,"path":"api/tags/CTF.json"}],"author":{"name":"RainSec","slug":"blog-author","avatar":"https://jsd.cdn.zzko.cn/gh/L2ksy0d/image-host@master/20220714/logo.jpg","link":"/","description":"艺术家思维去思考问题，工匠创造精神去开发","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{}}