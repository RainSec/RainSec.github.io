{"title":"URLDNS调试那些小事","uid":"609cb3bd3160d9a24e01a566229d052d","slug":"URLDNS调试那些小事","date":"2022-03-26T10:48:45.000Z","updated":"2023-04-11T11:40:27.921Z","comments":true,"path":"api/articles/URLDNS调试那些小事.json","keywords":null,"cover":"https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20220720/what-is-dns.3wivpbhx9do.png","content":"<h1 id=\"URLDNS调试那些小事\"><a href=\"#URLDNS调试那些小事\" class=\"headerlink\" title=\"URLDNS调试那些小事\"></a>URLDNS调试那些小事</h1><p>近期在看javaweb相关的知识，ysoserial作为反序列化利用链的神器，想稍微利用它来调试一个简单的urldns利用链，进而了解这个工具。</p>\n<h4 id=\"ysoserial链接：\"><a href=\"#ysoserial链接：\" class=\"headerlink\" title=\"ysoserial链接：\"></a>ysoserial链接：</h4><pre class=\"line-numbers language-txt\" data-language=\"txt\"><code class=\"language-txt\">下载地址: https://github.com/frohoff/ysoserial\n这里用jdk1.8来编译<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h4 id=\"编译ysoserial\"><a href=\"#编译ysoserial\" class=\"headerlink\" title=\"编译ysoserial\"></a>编译ysoserial</h4><p>用JIdea打开导入，会自动导入依赖，导入以后可能还会出现pom.xml红色表示找不到对应依赖的情况，这时可以进入依赖文件夹，可能是用于多个版本jar下载到了其他版本，删除版本然后，再重下载即可（俺在这里卡了好久）。</p>\n<p>下载好后进入GeneratePayload这个类</p>\n<p>进行run，若出现报错可能对应的jar包的版本不对，删除jar包重新下载。</p>\n<p>若运行成功后</p>\n<p><img src=\"https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20220720/image-1.png\" alt=\"image-20220319164133435\"></p>\n<p>按下蓝色小闪电，然后package进行编译打包。</p>\n<p>target目录下会显示编译好的jar包。</p>\n<h4 id=\"漏洞搭建\"><a href=\"#漏洞搭建\" class=\"headerlink\" title=\"漏洞搭建\"></a>漏洞搭建</h4><p>建立maven项目：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">import</span> <span class=\"token namespace\">java<span class=\"token punctuation\">.</span>io<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">FileInputStream</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token namespace\">java<span class=\"token punctuation\">.</span>io<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">ObjectInputStream</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> bug <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">Exception</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">FileInputStream</span> inputStream <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">FileInputStream</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"poc.ser\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">ObjectInputStream</span> oi <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ObjectInputStream</span><span class=\"token punctuation\">(</span>inputStream<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        oi<span class=\"token punctuation\">.</span><span class=\"token function\">readObject</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        oi<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"反序列化完成\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>ps：漏洞环境不太准确，只是把序列化文件读进去，然后进行反序列化而已。</p>\n<p>生成恶意poc：</p>\n<p>在<a href=\"http://dnslog.cn/\">http://dnslog.cn/</a></p>\n<p>获得临时域名：0dt3fc.dnslog.cn</p>\n<p> java -jar .\\ysoserial-0.0.5-all.jar URLDNS “<a href=\"http://0dt3fc.dnslog.cn&quot;/\">http://0dt3fc.dnslog.cn\"</a> &gt; poc.ser</p>\n<p>将poc.ser放在漏洞项目根目录运行即可。</p>\n<p><img src=\"https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20220720/image-2.png\" alt=\"image-20220319165349429\"></p>\n<p>注：这里有一个坑点，要是以powershell去生成poc文件会执行报错，需cmd，可参考：<br><a href=\"https://gitter.im/frohoff/ysoserial/archives/2017/09/18\">https://gitter.im/frohoff/ysoserial/archives/2017/09/18</a></p>\n<h4 id=\"调试\"><a href=\"#调试\" class=\"headerlink\" title=\"调试\"></a>调试</h4><p>大致原理是java.util.HashMap 重写了 readObject, 在反序列化时会调用 hash 函数计算 key 的 hashCode.而 java.net.URL 的 hashCode 在计算时会调用 getHostAddress 来解析域名, 从而发出 DNS 请求，常用作无回显情况下验证java反序列漏洞的情况（俺没碰见过，可能是太菜了，或者运气不好哦）。</p>\n<p>在URLDNS.java下，作者写了如下利用链：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">*   Gadget Chain:\n*     HashMap.readObject()\n*       HashMap.putVal()\n*         HashMap.hash()\n*           URL.hashCode()\n*<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>在刚开始会new  HashMap()，</p>\n<p><img src=\"https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20220720/image-3.png\" alt=\"image-20220319171527663\"></p>\n<p>接下来会调用会调用putVal方法，putVal作用在于HashMap放入键值，这里调用了hash方法来处理key</p>\n<p><img src=\"https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20220720/image-4.png\" alt=\"image-20220319172033597\"></p>\n<p>值得关注key.hashCode()方法，</p>\n<p><img src=\"https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20220720/image-5.png\" alt=\"image-20220319172118524\"></p>\n<p>当hashcode==-1时会执行hashCode = handler.hashCode(this);（默认值为-1所以这里不用太在意）</p>\n<p>这里调用getHostAddress</p>\n<p><img src=\"https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20220720/image-6.png\" alt=\"image-20220319172245170\"></p>\n<p>他会进行dns的查询。</p>\n<p>然后就是一些细节：</p>\n<p>在Hashmap的readObject</p>\n<p><img src=\"https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20220720/image-7.png\" alt=\"image-20220319172426593\"></p>\n<p>key是从readObject得到的，说明key应该在writeObject被写入了。</p>\n<p>WriteObject最后会调用到internalWriteEntries(s)。</p>\n<p><img src=\"https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20220720/image-8.png\" alt=\"image-20220319172535442\"></p>\n<p>从中可看出，key和value都来自table，即HashMap中table的值。</p>\n<p>要修改table一般会调用HashMap的put方法，从而调用putVal，这样就会造成dns请求，会和目标机器的混淆。</p>\n<p><img src=\"https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20220720/image-9.png\" alt=\"img\"></p>\n<p>这里ysoserial 继承抽象类SilentURLStreamHandler类，重写了openConnection和getHostAddress，</p>\n<p>可以直接返回NULL，不会有后续的操作，从而不会dns请求。</p>\n<p>知道这些我们也可以通过反射来将poc再写一遍，网上大佬们写的很完善了，俺就不班门弄斧了。</p>\n<p>参考：</p>\n<p><a href=\"https://www.yuque.com/pmiaowu/gpy1q8/ygthda\">https://www.yuque.com/pmiaowu/gpy1q8/ygthda</a></p>\n<p><a href=\"https://baijiahao.baidu.com/s?id=1711619506108128533&amp;wfr=spider&amp;for=pc\">https://baijiahao.baidu.com/s?id=1711619506108128533&amp;wfr=spider&amp;for=pc</a></p>\n<p><a href=\"https://xz.aliyun.com/t/7157?page=5\">https://xz.aliyun.com/t/7157?page=5</a></p>\n","text":"URLDNS调试那些小事近期在看javaweb相关的知识，ysoserial作为反序列化利用链的神器，想稍微利用它来调试一个简单的urldns利用链，进而了解这个工具。 ysoserial链接：下载地址: https://github.com/frohoff/ysoserial 这里用jdk1.8来编译 编译ysoserial用JIdea打开导入，会自动导入依赖，导入以后可能还会出现pom.xml红色表示找不到对应依赖的情况，这时可以进入依赖文件夹，可能是用于多个版本jar下载到了其他版本，删除...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"渗透测试","slug":"渗透测试","count":10,"path":"api/categories/渗透测试.json"}],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#URLDNS%E8%B0%83%E8%AF%95%E9%82%A3%E4%BA%9B%E5%B0%8F%E4%BA%8B\"><span class=\"toc-text\">URLDNS调试那些小事</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#ysoserial%E9%93%BE%E6%8E%A5%EF%BC%9A\"><span class=\"toc-text\">ysoserial链接：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BC%96%E8%AF%91ysoserial\"><span class=\"toc-text\">编译ysoserial</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%BC%8F%E6%B4%9E%E6%90%AD%E5%BB%BA\"><span class=\"toc-text\">漏洞搭建</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%B0%83%E8%AF%95\"><span class=\"toc-text\">调试</span></a></li></ol></li></ol></li></ol></li></ol>","author":{"name":"KID","slug":"kid","avatar":"https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20220720/KID.5419jujfw8s0.jpg","link":"https://rainsec.cn","description":"","socials":{}},"mapped":true,"prev_post":{"title":"Tomcat内存马简析","uid":"a5eb3b6436793531605058c41325d8af","slug":"Tomcat内存马解析","date":"2022-03-26T10:48:45.000Z","updated":"2023-04-11T11:40:19.169Z","comments":true,"path":"api/articles/Tomcat内存马解析.json","keywords":null,"cover":"https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20221025/images.7i3pppfv9fc.jpg","text":"Tomcat内存马简析 webshell木马配合webshell管理工具可以方便对于服务器、内网进行进一步的维权、入侵，随着对文件内容查杀、以Ai对流量特征和行为模式的查杀等等手段，普通文件形式的webshell木马可靠性越来越差。也许好不容易绕过waf传上去两分钟不到就被杀掉了，所以攻击方在近些年也慢慢的研发出“无文件”的webshell木马，即内存马。内存马的概念提出比较久的，但走进视野就近几年的事情，每隔一段时间总能看到不少师傅提出新的内存马实现方法，这里简单说下利用JavaWeb的三大组...","link":"","photos":[],"count_time":{"symbolsCount":"26k","symbolsTime":"24 mins."},"categories":[{"name":"渗透测试","slug":"渗透测试","count":10,"path":"api/categories/渗透测试.json"}],"tags":[],"author":{"name":"KID","slug":"kid","avatar":"https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20220720/KID.5419jujfw8s0.jpg","link":"https://rainsec.cn","description":"","socials":{}}},"next_post":{"title":"云原生项目Fuzz特点及思考","uid":"5c3101d9d1523d1869d7d8a2235ebd0e","slug":"Go-Fuzz解析与思考","date":"2022-03-25T10:48:45.000Z","updated":"2023-04-11T11:39:19.889Z","comments":true,"path":"api/articles/Go-Fuzz解析与思考.json","keywords":null,"cover":"https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20220720/gofuzzcover.png","text":"Go-fuzz的解析与思考go-fuzz Go-fuzz的原理很多都是基于AFL，这里只分析了一些它独特的地方，收获很多，也希望可以和大家交流，如有分析错误还望交流指正。 ​ go-fuzz是google开源的一款go语言fuzz框架，它和AFL很大的一个不同是在于，AFL通常通过对未修改的文件的输入进行操作，而go-fuzz需要你编写一个Fuzz函数，go-fuzz通过不断的调用该函数来进行fuzz，前者通常会为每一个输入创建一个新的进程，后者则是不断的调用Fuzz函数因此不需要经常启动或者重...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[{"name":"漏洞挖掘","slug":"漏洞挖掘","count":6,"path":"api/categories/漏洞挖掘.json"}],"tags":[{"name":"Fuzz","slug":"Fuzz","count":4,"path":"api/tags/Fuzz.json"}],"author":{"name":"Clock","slug":"clock","avatar":"https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20220720/clocklogo.jpg","link":"https://rainsec.cn","description":"","socials":{}}}}