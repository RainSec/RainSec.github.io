{"title":"灵活的修改Burp请求","uid":"49976eacba4bfec6b25d67dd692a855b","slug":"灵活的修改Burp请求","date":"2022-03-05T10:38:45.000Z","updated":"2023-04-11T13:10:02.800Z","comments":true,"path":"api/articles/灵活的修改Burp请求.json","keywords":null,"cover":"https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20220720/burp.png","content":"<h1 id=\"灵活的修改Burp请求\"><a href=\"#灵活的修改Burp请求\" class=\"headerlink\" title=\"灵活的修改Burp请求\"></a>灵活的修改Burp请求</h1><p>  在日常渗透测试中经常会遇到请求头需要替换、请求或响应内容需要解密等一系列麻烦的事。更换请求头可以通过<code>Burp</code>的<code>Match and Replace</code>功能来实现，加解密也有一些插件可以实现，但是它们普遍存在着以下缺陷：</p>\n<ul>\n<li><p>自定义数据不能进行保存</p>\n</li>\n<li><p>加解密不能灵活的指定位置</p>\n</li>\n</ul>\n<p>  带着这些需求，笔者在寻找工具时发现了一款有趣的插件<code>Python Scripter: https://github.com/PortSwigger/python-scripter</code> </p>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>  与其说这是一个插件，不如说其更像是一个框架。简单地说，它的功能是将当前请求上下文作为全局变量传入用户自定义的代码中，也就是说用户可以随意的修改请求信息。它本身的代码也是很简单的</p>\n<p>  <img src=\"https://cdn.jsdelivr.net/gh/L2ksy0d/image-host@master/20220325/image1.4mg8n7lywo40.png\" alt=\"img\"></p>\n<p>  首先是将请求信息传递给用户自定义脚本的集合中，然后每个脚本分别对请求信息进行处理</p>\n<p>  <img src=\"https://cdn.jsdelivr.net/gh/L2ksy0d/image-host@master/20220325/image2.2hu9hc06lfi0.png\" alt=\"img\"></p>\n<p>  这里的处理其实就是用户编译代码通过后，把操作<code>Burp</code>的接口作为全局变量传递进去并执行</p>\n<p>  <img src=\"https://cdn.jsdelivr.net/gh/L2ksy0d/image-host@master/20220325/image3.3fssj0kye600.png\" alt=\"img\"></p>\n<p>  这就实现了以插件“写”插件。</p>\n<p>  <img src=\"https://cdn.jsdelivr.net/gh/L2ksy0d/image-host@master/20220325/image4.3vlf70bxkv80.png\" alt=\"img\"></p>\n<h2 id=\"完善\"><a href=\"#完善\" class=\"headerlink\" title=\"完善\"></a>完善</h2><p>  上文的框架让我们有了灵活操纵请求的希望，而<code>https://github.com/lanmaster53/pyscripter-er/blob/master/pyscripterer.py</code> 则成功的将其变为了现实。其定义了一个接受<code>messageInfo</code>等请求信息的<code>Class</code>，并且提供了许多写好的方法以便于更新请求信息，例如删除一个请求头，可以这么写：</p>\n<p>  <img src=\"https://cdn.jsdelivr.net/gh/L2ksy0d/image-host@master/20220325/image5.2blkgsq9j98g.png\" alt=\"img\"></p>\n<p>  这样任何请求都将不存在<code>Sec-Ch-Ua-Mobile</code>这个字段，<code>remove_request_headers</code>就是<code>pyscripter-er</code>中定义好的一个方法，主要作用就是遍历移除指定<code>header_name</code>开头的<code>haeder</code>字段并重新构造请求包</p>\n<p>  <img src=\"https://cdn.jsdelivr.net/gh/L2ksy0d/image-host@master/20220325/image6.2agpex1rcy3o.png\" alt=\"img\"></p>\n<p>  如果要增加新的通用函数只需要在<code>pyscripterer</code>中进行修改即可，比如增加一个添加请求头的方法</p>\n<p>  <img src=\"https://cdn.jsdelivr.net/gh/L2ksy0d/image-host@master/20220325/image7.37vfz4dftim0.png\" alt=\"img\"></p>\n<h2 id=\"实战\"><a href=\"#实战\" class=\"headerlink\" title=\"实战\"></a>实战</h2><p>  接下来用实战来检验下，在测试某个网站时碰到了如下加密请求</p>\n<p>  <img src=\"https://cdn.jsdelivr.net/gh/L2ksy0d/image-host@master/20220325/image8.1y7vruzai6cg.png\" alt=\"img\"></p>\n<p>  通过分析<code>JS</code>发现其加密算法是<code>base64</code>加上一定的换位：</p>\n<p>  <img src=\"https://cdn.jsdelivr.net/gh/L2ksy0d/image-host@master/20220325/image9.e84l9bc9ndc.png\" alt=\"img\"></p>\n<p>  那我们的思路就是每次请求时找到<code>jsonparams</code>这个参数，并对其进行加密，这样在发送请求时我们看到的参数就是未加密的了，方便我们在<code>repeater</code>进行测试。首先创建一个函数用于获取参数，根据参数名遍历即可</p>\n<p>  <img src=\"https://cdn.jsdelivr.net/gh/L2ksy0d/image-host@master/20220325/image10.6sygad9jx6k0.png\" alt=\"img\"></p>\n<p>  删除找到的参数，之后重新创建一个新的参数，其值为加密后的值</p>\n<p>  <img src=\"https://cdn.jsdelivr.net/gh/L2ksy0d/image-host@master/20220325/image11.76bg61giaqk0.png\" alt=\"img\"></p>\n<p>  加密函数</p>\n<p>  <img src=\"https://cdn.jsdelivr.net/gh/L2ksy0d/image-host@master/20220325/image12.4rljs094wni0.png\" alt=\"img\"></p>\n<p>  结合起来调用</p>\n<p>  <img src=\"https://cdn.jsdelivr.net/gh/L2ksy0d/image-host@master/20220325/image13.4yz7e159y7g0.png\" alt=\"img\"></p>\n<p>  当我们发送请求</p>\n  <pre class=\"line-numbers language-HTTP\" data-language=\"HTTP\"><code class=\"language-HTTP\">jsonparams={\"UserId\":\"1234\"}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>  可以从<code>logger</code>中观测到其发生了变化，在<code>intruder</code>中的请求也会发生变化，再碰到需要爆破的场景时也是很实用的。</p>\n<p>  <img src=\"https://cdn.jsdelivr.net/gh/L2ksy0d/image-host@master/20220325/image14.6jho2erfn2g0.png\" alt=\"img\"></p>\n<p>  除了对请求处理之外，我们也可以对响应做处理，而且操作结果会直接在当前页面里显现出来，不会像请求一样需要在日志里查看其修改结果，可以很好的解决响应内容加密的问题。还拿上面的请求为例，其响应内容是未加密的，这里给它做一次加密，简单的对相应内容做一次替换：</p>\n<p>  <img src=\"https://cdn.jsdelivr.net/gh/L2ksy0d/image-host@master/20220325/image15.4rxk8cilfuw0.png\" alt=\"img\"></p>\n<p>  使用<code>base64</code>进行加密</p>\n<p>  <img src=\"https://cdn.jsdelivr.net/gh/L2ksy0d/image-host@master/20220325/image16.3qx8u8ni4020.png\" alt=\"img\"></p>\n<p>  最终的结果如下</p>\n<p>  <img src=\"https://cdn.jsdelivr.net/gh/L2ksy0d/image-host@master/20220325/image18.63sojynzc5s0.png\" alt=\"img\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>  使用<code>python-scripter</code>可以灵活的写出适用于不同场景下的插件，同时可以将其保存为模板，方便之后遇到相似情况下的使用。本次虽然遇到的加密算法比较简单，但是以<code>python</code>执行<code>jS</code>的便捷，相信再复杂些的算法也能很快的实现。</p>\n<p>  本文中修改过后的<code>pyscripterer</code>已上传至<code>github</code>: <a href=\"https://github.com/No4l/python-scripter/blob/main/pyscripterer.py\">https://github.com/No4l/python-scripter/blob/main/pyscripterer.py</a></p>\n","text":"灵活的修改Burp请求 在日常渗透测试中经常会遇到请求头需要替换、请求或响应内容需要解密等一系列麻烦...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"渗透测试","slug":"渗透测试","count":10,"path":"api/categories/渗透测试.json"}],"tags":[{"name":"BurpSuite","slug":"BurpSuite","count":2,"path":"api/tags/BurpSuite.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%81%B5%E6%B4%BB%E7%9A%84%E4%BF%AE%E6%94%B9Burp%E8%AF%B7%E6%B1%82\"><span class=\"toc-text\">灵活的修改Burp请求</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">简介</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%8C%E5%96%84\"><span class=\"toc-text\">完善</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E6%88%98\"><span class=\"toc-text\">实战</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol></li></ol>","author":{"name":"RainSec","slug":"blog-author","avatar":"https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20220714/logo.jpg","link":"/","description":"艺术家思维去思考问题，工匠创造精神去开发","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"runC-fuzz","uid":"280c433ecf11c03958de8f79adb38b6b","slug":"RunC-Fuzz","date":"2022-03-11T10:48:45.000Z","updated":"2023-04-11T13:08:45.168Z","comments":true,"path":"api/articles/RunC-Fuzz.json","keywords":null,"cover":"https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20220720/runc.7k7938728c80.webp","text":"runC-fuzz​本文主要是根据AdaLogics开源的runc-fuzzers和自己之前做的一些...","link":"","photos":[],"count_time":{"symbolsCount":"4.2k","symbolsTime":"4 mins."},"categories":[{"name":"漏洞挖掘","slug":"漏洞挖掘","count":6,"path":"api/categories/漏洞挖掘.json"}],"tags":[{"name":"Fuzz","slug":"Fuzz","count":4,"path":"api/tags/Fuzz.json"}],"author":{"name":"RainSec","slug":"blog-author","avatar":"https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20220714/logo.jpg","link":"/","description":"艺术家思维去思考问题，工匠创造精神去开发","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"容器进程切换漏洞","uid":"2f1f68ab5dfcea1c92e15793016ea760","slug":"容器进程切换漏洞","date":"2022-02-13T10:48:45.000Z","updated":"2023-04-11T13:09:57.496Z","comments":true,"path":"api/articles/容器进程切换漏洞.json","keywords":null,"cover":"https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20220720/docker.3x87dx4ktik0.png","text":"容器进程切换思考前置技术Magic Link​ /proc/目录下存在很多的链接文件，但是在Linu...","link":"","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[{"name":"容器安全","slug":"容器安全","count":1,"path":"api/categories/容器安全.json"}],"tags":[{"name":"容器安全","slug":"容器安全","count":1,"path":"api/tags/容器安全.json"}],"author":{"name":"RainSec","slug":"blog-author","avatar":"https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20220714/logo.jpg","link":"/","description":"艺术家思维去思考问题，工匠创造精神去开发","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}