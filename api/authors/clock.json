{"name":"Clock","slug":"clock","avatar":"https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20220720/clocklogo.jpg","link":"https://rainsec.cn","description":"","socials":{},"post_list":[{"title":"Angr Taint Analysis","uid":"1ac0942cada2f27dfbac108a2c01d426","slug":"Angr Taint Analysis","date":"2023-03-14T07:07:45.000Z","updated":"2023-04-11T11:38:41.065Z","comments":true,"path":"api/articles/Angr Taint Analysis.json","keywords":null,"cover":"https://cdn.staticaly.com/gh/L2ksy0d/picx-images-hosting@master/20230406/image.7j4ghfi4dy00.png","text":"Angr Taint Analysis 本人一直致力于二进制分析和自动化漏洞挖掘领域，这次抛砖引玉，希望可以大家多多指导 污点分析的基本分类： 动态污点分析 静态污点分析 上述分析方式都有自己的优缺点，对于动态污点分析来说，缺点如下： 分析结果依赖输入。 一些隐式调用难以跟踪。 静态污点分析的缺点如下： 路径爆炸问题。 一些程序特性只有在动态执行的过程中才会展示出来。 angr本身的知识内容多而且杂乱，下面对一些核心的基础知识进行一下讲解。 angr https://web.wpi.edu/Pu...","link":"","photos":[],"count_time":{"symbolsCount":"32k","symbolsTime":"29 mins."},"categories":[{"name":"漏洞挖掘","slug":"漏洞挖掘","count":6,"path":"api/categories/漏洞挖掘.json"}],"tags":[{"name":"漏洞挖掘","slug":"漏洞挖掘","count":2,"path":"api/tags/漏洞挖掘.json"}],"author":{"name":"Clock","slug":"clock","avatar":"https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20220720/clocklogo.jpg","link":"https://rainsec.cn","description":"","socials":{}},"feature":true},{"title":"AddressSanitizer 漏洞检测技术剖析","uid":"9830e1ecf0b844b9805cff1f477e18bc","slug":"AddressSanitizer","date":"2022-10-08T07:07:45.000Z","updated":"2023-04-11T11:38:30.765Z","comments":true,"path":"api/articles/AddressSanitizer.json","keywords":null,"cover":"https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20221015/sanitizers.5w0qyt2gbqg0.webp","text":"AddressSanitizer 漏洞检测技术剖析 类似AFL之类的Fuzzing技术不断强大的一个核心原因就是漏洞检测能力的不断增强，作为AFL这款经典工具的核心，ASAN的漏洞检测核心能力值得关注。 ASAN简介 ASAN其实本身是作为LLVM项目的一部分存在于Clang里面，其作用就是一个强大的内存错误检测器，它由一个编译插桩模块和一个运行时库组成，据官网介绍其可以检测以下类型的漏洞： Out-of-bounds accesses to heap, stack and globals. U...","link":"","photos":[],"count_time":{"symbolsCount":"7.4k","symbolsTime":"7 mins."},"categories":[{"name":"漏洞挖掘","slug":"漏洞挖掘","count":6,"path":"api/categories/漏洞挖掘.json"}],"tags":[{"name":"漏洞挖掘","slug":"漏洞挖掘","count":2,"path":"api/tags/漏洞挖掘.json"}],"author":{"name":"Clock","slug":"clock","avatar":"https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20220720/clocklogo.jpg","link":"https://rainsec.cn","description":"","socials":{}}},{"title":"Fuzzing之Grammars","uid":"001f56a1173240fc9f846bb4717903d4","slug":"Fuzzing之Grammers","date":"2022-07-31T08:42:45.000Z","updated":"2023-04-11T11:39:14.837Z","comments":true,"path":"api/articles/Fuzzing之Grammers.json","keywords":null,"cover":"https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20220731/fuzzinggrammar.jpeg","text":"Fuzzing之GrammarsFuzzing input​ Fuzzing的一大核心思想其实就是通过大量的Input去触发程序的各个分支逻辑，因此Fuzzing的成功与否和Input的生成关系密切。Input的格式多种多样，可以是文件，代码，json数据等等。但是各种各样的数据都有自己的格式，程序的输入也是如此，那么在生成Input的过程中，格式化非常关键，程序无法接受的输入对于Fuzzing来说是毫无意义的。 ​ 为了很好的描述一个程序的输入，一个很有必要的事情是为输入制定一些语法规范。比如...","link":"","photos":[],"count_time":{"symbolsCount":"35k","symbolsTime":"32 mins."},"categories":[{"name":"漏洞挖掘","slug":"漏洞挖掘","count":6,"path":"api/categories/漏洞挖掘.json"}],"tags":[{"name":"Fuzz","slug":"Fuzz","count":4,"path":"api/tags/Fuzz.json"}],"author":{"name":"Clock","slug":"clock","avatar":"https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20220720/clocklogo.jpg","link":"https://rainsec.cn","description":"","socials":{}}},{"title":"Linux Kernel 保护机制绕过","uid":"ca9ebcc3809bcde27e81d904c30455e1","slug":"Linux Kernel 保护机制绕过","date":"2022-07-19T10:48:45.000Z","updated":"2023-04-11T11:39:44.197Z","comments":true,"path":"api/articles/Linux Kernel 保护机制绕过.json","keywords":null,"cover":"https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20220720/kernelcover.png","text":"Linux Kernel 保护机制绕过 好久没搞kernel的洞了，最近分析的这方面的洞有点多，相关的Exp任务也比较多，因此学习总结一下方便查找和记忆。 SMEP + KPTI bypass​ SMEP是SupervisorModeExecutionPrevention的缩写，主要的作用其实就是抵御类似ret2user这样的攻击，简单来说就是阻止内核执行用户态传递的代码。 ​ 检测计算机是否开启SMEP保护的方式很简单，cat /proc/cpuinfo | grep smep，如果有匹配到一...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"12 mins."},"categories":[{"name":"Linux Kernel","slug":"Linux-Kernel","count":1,"path":"api/categories/Linux-Kernel.json"}],"tags":[{"name":"Linux Kernel","slug":"Linux-Kernel","count":1,"path":"api/tags/Linux-Kernel.json"}],"author":{"name":"Clock","slug":"clock","avatar":"https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20220720/clocklogo.jpg","link":"https://rainsec.cn","description":"","socials":{}}},{"title":"云原生项目Fuzz特点及思考","uid":"5c3101d9d1523d1869d7d8a2235ebd0e","slug":"Go-Fuzz解析与思考","date":"2022-03-25T10:48:45.000Z","updated":"2023-04-11T11:39:19.889Z","comments":true,"path":"api/articles/Go-Fuzz解析与思考.json","keywords":null,"cover":"https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20220720/gofuzzcover.png","text":"Go-fuzz的解析与思考go-fuzz Go-fuzz的原理很多都是基于AFL，这里只分析了一些它独特的地方，收获很多，也希望可以和大家交流，如有分析错误还望交流指正。 ​ go-fuzz是google开源的一款go语言fuzz框架，它和AFL很大的一个不同是在于，AFL通常通过对未修改的文件的输入进行操作，而go-fuzz需要你编写一个Fuzz函数，go-fuzz通过不断的调用该函数来进行fuzz，前者通常会为每一个输入创建一个新的进程，后者则是不断的调用Fuzz函数因此不需要经常启动或者重...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[{"name":"漏洞挖掘","slug":"漏洞挖掘","count":6,"path":"api/categories/漏洞挖掘.json"}],"tags":[{"name":"Fuzz","slug":"Fuzz","count":4,"path":"api/tags/Fuzz.json"}],"author":{"name":"Clock","slug":"clock","avatar":"https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20220720/clocklogo.jpg","link":"https://rainsec.cn","description":"","socials":{}}},{"title":"runC-fuzz","uid":"280c433ecf11c03958de8f79adb38b6b","slug":"RunC-Fuzz","date":"2022-03-11T10:48:45.000Z","updated":"2023-04-11T11:40:14.109Z","comments":true,"path":"api/articles/RunC-Fuzz.json","keywords":null,"cover":"https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20220720/runc.7k7938728c80.webp","text":"runC-fuzz​本文主要是根据AdaLogics开源的runc-fuzzers和自己之前做的一些fuzz，研究一下可能的问题和相关的解决方案。在此之前可能会有朋友对runc比较陌生，可以参考一下之前的文章：https://bbs.pediy.com/thread-271130.htm AdaLogics如何fuzz​runC是go语言编写的，那么对于fuzz引擎的选择毫无疑问应该是go-fuzz，纵观runC的项目结构，其实就是包裹了libcontainer，这也不难理解，因为在我的印象里面...","link":"","photos":[],"count_time":{"symbolsCount":"4.2k","symbolsTime":"4 mins."},"categories":[{"name":"漏洞挖掘","slug":"漏洞挖掘","count":6,"path":"api/categories/漏洞挖掘.json"}],"tags":[{"name":"Fuzz","slug":"Fuzz","count":4,"path":"api/tags/Fuzz.json"}],"author":{"name":"Clock","slug":"clock","avatar":"https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20220720/clocklogo.jpg","link":"https://rainsec.cn","description":"","socials":{}}},{"title":"容器进程切换漏洞","uid":"2f1f68ab5dfcea1c92e15793016ea760","slug":"容器进程切换漏洞","date":"2022-02-13T10:48:45.000Z","updated":"2023-04-11T11:38:15.281Z","comments":true,"path":"api/articles/容器进程切换漏洞.json","keywords":null,"cover":"https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20220720/docker.3x87dx4ktik0.png","text":"容器进程切换思考前置技术Magic Link​ /proc/目录下存在很多的链接文件，但是在Linux 也存在一种特殊的链接文件，这种文件的大小为0，我们知道普通的链接文件的大小等于链接目标的文件路径长度，但是Magic Link的大小为0，它们在打开方式上面也存在差别，普通链接文件会解析出链接文件的路径然后进行打开操作，但是Magic LInk的话不会这样，它会调用内核专门的处理函数，然后返回目标文件的文件描述符。 匿名文件​ Linux Anonymous Files，也叫匿名文件，匿名文件...","link":"","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[{"name":"容器安全","slug":"容器安全","count":1,"path":"api/categories/容器安全.json"}],"tags":[{"name":"容器安全","slug":"容器安全","count":1,"path":"api/tags/容器安全.json"}],"author":{"name":"Clock","slug":"clock","avatar":"https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20220720/clocklogo.jpg","link":"https://rainsec.cn","description":"","socials":{}}},{"title":"RealWorld CTF之qiling框架分析","uid":"c240e7132c70272bfb31ce1eb51c281b","slug":"Qilin框架分析","date":"2022-01-28T10:48:45.000Z","updated":"2023-04-11T11:39:57.249Z","comments":true,"path":"api/articles/Qilin框架分析.json","keywords":null,"cover":"https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20220720/realworld.png","text":"RealWorld CTF之qiling框架分析qiling​当时题目就给了一个qiling的使用的用例，甚至和官方文档上面的用例差不多因此肯定是库的问题。 #!/usr/bin/env python3 import os import sys import base64 import tempfile # pip install qiling==1.4.1 from qiling import Qiling def my_sandbox(path, rootfs): ql = Qiling([...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[{"name":"CTF","slug":"CTF","count":1,"path":"api/categories/CTF.json"},{"name":"容器安全","slug":"CTF/容器安全","count":1,"path":"api/categories/CTF/容器安全.json"}],"tags":[{"name":"CTF","slug":"CTF","count":1,"path":"api/tags/CTF.json"}],"author":{"name":"Clock","slug":"clock","avatar":"https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20220720/clocklogo.jpg","link":"https://rainsec.cn","description":"","socials":{}}}],"categories":4,"tags":8,"word_count":"134k","post_count":8}