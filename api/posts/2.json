{"total":24,"pageSize":12,"pageCount":2,"data":[{"title":"Webshell工具加密流量解析","uid":"06322427d537eca1634c7950b5477253","slug":"Webshell工具加密流量解析","date":"2022-07-19T11:48:45.000Z","updated":"2023-04-11T11:40:32.157Z","comments":true,"path":"api/articles/Webshell工具加密流量解析.json","cover":"https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20220722/bingxie.10ryoh4zjlxs.png","text":"前言webshell管理工具作为进一步信息收集、内网渗透、获取更高权限等功能的好帮手，常出现在攻防对抗和渗透测试场景下，其自带的流量加密用来绕过其waf、ids等安全设备的连接，这里简单说下蚁剑、哥斯拉、冰蝎3.0这三款较为流行的工具在默认情况下的流量加密方式和解密方法，可以帮助守方在复盘时更好的攻击链还原和检测。 蚁剑蚁剑的加密手段比较简单，在配置界面的加密手段只有base64和rot13，这两者都是无需密钥可直接进行解密的密码类型，这里以base64为例：提取参数后的编码直接进行base64...","link":"","photos":[],"count_time":{"symbolsCount":"49k","symbolsTime":"45 mins."},"categories":[{"name":"渗透测试","slug":"渗透测试","count":10,"path":"api/categories/渗透测试.json"}],"tags":[],"author":{"name":"KID","slug":"kid","avatar":"https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20220720/KID.5419jujfw8s0.jpg","link":"https://rainsec.cn","description":"","socials":{}}},{"title":"Linux Kernel 保护机制绕过","uid":"ca9ebcc3809bcde27e81d904c30455e1","slug":"Linux Kernel 保护机制绕过","date":"2022-07-19T10:48:45.000Z","updated":"2023-04-11T11:39:44.197Z","comments":true,"path":"api/articles/Linux Kernel 保护机制绕过.json","cover":"https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20220720/kernelcover.png","text":"Linux Kernel 保护机制绕过 好久没搞kernel的洞了，最近分析的这方面的洞有点多，相关的Exp任务也比较多，因此学习总结一下方便查找和记忆。 SMEP + KPTI bypass​ SMEP是SupervisorModeExecutionPrevention的缩写，主要的作用其实就是抵御类似ret2user这样的攻击，简单来说就是阻止内核执行用户态传递的代码。 ​ 检测计算机是否开启SMEP保护的方式很简单，cat /proc/cpuinfo | grep smep，如果有匹配到一...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"12 mins."},"categories":[{"name":"Linux Kernel","slug":"Linux-Kernel","count":1,"path":"api/categories/Linux-Kernel.json"}],"tags":[{"name":"Linux Kernel","slug":"Linux-Kernel","count":1,"path":"api/tags/Linux-Kernel.json"}],"author":{"name":"Clock","slug":"clock","avatar":"https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20220720/clocklogo.jpg","link":"https://rainsec.cn","description":"","socials":{}}},{"title":"Ubuntu 更新内核到指定版本","uid":"13f80bc1c75f3199fa7b182a57317bf0","slug":"Ubuntu20.04 升级降级内核到指定版本","date":"2022-03-28T10:38:45.000Z","updated":"2023-04-11T11:40:23.693Z","comments":true,"path":"api/articles/Ubuntu20.04 升级降级内核到指定版本.json","cover":"https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20220720/Ubuntucover.webp","text":"记一次更新内核到5.8.0-33-generic 更新到指定版本查看当前版本$ uname -r 4.15.0-101-generic $ lsb_release -a No LSB modules are available. Distributor ID: Ubuntu Description:...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"系统运维","slug":"系统运维","count":1,"path":"api/categories/系统运维.json"}],"tags":[{"name":"Linux","slug":"Linux","count":1,"path":"api/tags/Linux.json"}],"author":{"name":"Zitui","slug":"zitui","avatar":"https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20220720/zitui_logo.jpg","link":"https://rainsec.cn","description":"","socials":{}}},{"title":"URLDNS调试那些小事","uid":"609cb3bd3160d9a24e01a566229d052d","slug":"URLDNS调试那些小事","date":"2022-03-26T10:48:45.000Z","updated":"2023-04-11T11:40:27.921Z","comments":true,"path":"api/articles/URLDNS调试那些小事.json","cover":"https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20220720/what-is-dns.3wivpbhx9do.png","text":"URLDNS调试那些小事近期在看javaweb相关的知识，ysoserial作为反序列化利用链的神器，想稍微利用它来调试一个简单的urldns利用链，进而了解这个工具。 ysoserial链接：下载地址: https://github.com/frohoff/ysoserial 这里用jdk1.8来编译 编译ysoserial用JIdea打开导入，会自动导入依赖，导入以后可能还会出现pom.xml红色表示找不到对应依赖的情况，这时可以进入依赖文件夹，可能是用于多个版本jar下载到了其他版本，删除...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"渗透测试","slug":"渗透测试","count":10,"path":"api/categories/渗透测试.json"}],"tags":[],"author":{"name":"KID","slug":"kid","avatar":"https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20220720/KID.5419jujfw8s0.jpg","link":"https://rainsec.cn","description":"","socials":{}}},{"title":"Tomcat内存马简析","uid":"a5eb3b6436793531605058c41325d8af","slug":"Tomcat内存马解析","date":"2022-03-26T10:48:45.000Z","updated":"2023-04-11T11:40:19.169Z","comments":true,"path":"api/articles/Tomcat内存马解析.json","cover":"https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20221025/images.7i3pppfv9fc.jpg","text":"Tomcat内存马简析 webshell木马配合webshell管理工具可以方便对于服务器、内网进行进一步的维权、入侵，随着对文件内容查杀、以Ai对流量特征和行为模式的查杀等等手段，普通文件形式的webshell木马可靠性越来越差。也许好不容易绕过waf传上去两分钟不到就被杀掉了，所以攻击方在近些年也慢慢的研发出“无文件”的webshell木马，即内存马。内存马的概念提出比较久的，但走进视野就近几年的事情，每隔一段时间总能看到不少师傅提出新的内存马实现方法，这里简单说下利用JavaWeb的三大组...","link":"","photos":[],"count_time":{"symbolsCount":"26k","symbolsTime":"24 mins."},"categories":[{"name":"渗透测试","slug":"渗透测试","count":10,"path":"api/categories/渗透测试.json"}],"tags":[],"author":{"name":"KID","slug":"kid","avatar":"https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20220720/KID.5419jujfw8s0.jpg","link":"https://rainsec.cn","description":"","socials":{}}},{"title":"云原生项目Fuzz特点及思考","uid":"5c3101d9d1523d1869d7d8a2235ebd0e","slug":"Go-Fuzz解析与思考","date":"2022-03-25T10:48:45.000Z","updated":"2023-04-11T11:39:19.889Z","comments":true,"path":"api/articles/Go-Fuzz解析与思考.json","cover":"https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20220720/gofuzzcover.png","text":"Go-fuzz的解析与思考go-fuzz Go-fuzz的原理很多都是基于AFL，这里只分析了一些它独特的地方，收获很多，也希望可以和大家交流，如有分析错误还望交流指正。 ​ go-fuzz是google开源的一款go语言fuzz框架，它和AFL很大的一个不同是在于，AFL通常通过对未修改的文件的输入进行操作，而go-fuzz需要你编写一个Fuzz函数，go-fuzz通过不断的调用该函数来进行fuzz，前者通常会为每一个输入创建一个新的进程，后者则是不断的调用Fuzz函数因此不需要经常启动或者重...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[{"name":"漏洞挖掘","slug":"漏洞挖掘","count":6,"path":"api/categories/漏洞挖掘.json"}],"tags":[{"name":"Fuzz","slug":"Fuzz","count":4,"path":"api/tags/Fuzz.json"}],"author":{"name":"Clock","slug":"clock","avatar":"https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20220720/clocklogo.jpg","link":"https://rainsec.cn","description":"","socials":{}}},{"title":"EventListener XSS","uid":"68bdee9933fc5dc89a593d8b4b4eaea6","slug":"EventListener XSS","date":"2022-03-25T10:38:45.000Z","updated":"2023-04-11T11:38:59.969Z","comments":true,"path":"api/articles/EventListener XSS.json","cover":"https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20220720/XSS_cover.jpg","text":"EventListener XSSXSS作为混”低保“的最佳漏洞，我们在日常测试中没少碰到，但是DOM型XSS就相对来说不容易被发现了，而本文要介绍的则是更难发现并利用的监听postMessage所导致漏洞。首先从事件监听器开始说起 事件监听器事件监控器可以为指定对象设置一个回调函数，当该对象的指定事件被触发时会被执行： &lt;table id=\"outside\"&gt; &lt;tr&gt;&lt;td id=\"t1\"&gt;one&lt;/td&gt;&lt;/tr&gt; &lt;tr&...","link":"","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[{"name":"渗透测试","slug":"渗透测试","count":10,"path":"api/categories/渗透测试.json"}],"tags":[{"name":"XSS","slug":"XSS","count":1,"path":"api/tags/XSS.json"}],"author":{"name":"Noel","slug":"noel","avatar":"https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20220211/noel.47xsfyg7vt40.webp","link":"https://rainsec.cn","description":"","socials":{}}},{"title":"runC-fuzz","uid":"280c433ecf11c03958de8f79adb38b6b","slug":"RunC-Fuzz","date":"2022-03-11T10:48:45.000Z","updated":"2023-04-11T11:40:14.109Z","comments":true,"path":"api/articles/RunC-Fuzz.json","cover":"https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20220720/runc.7k7938728c80.webp","text":"runC-fuzz​本文主要是根据AdaLogics开源的runc-fuzzers和自己之前做的一些fuzz，研究一下可能的问题和相关的解决方案。在此之前可能会有朋友对runc比较陌生，可以参考一下之前的文章：https://bbs.pediy.com/thread-271130.htm AdaLogics如何fuzz​runC是go语言编写的，那么对于fuzz引擎的选择毫无疑问应该是go-fuzz，纵观runC的项目结构，其实就是包裹了libcontainer，这也不难理解，因为在我的印象里面...","link":"","photos":[],"count_time":{"symbolsCount":"4.2k","symbolsTime":"4 mins."},"categories":[{"name":"漏洞挖掘","slug":"漏洞挖掘","count":6,"path":"api/categories/漏洞挖掘.json"}],"tags":[{"name":"Fuzz","slug":"Fuzz","count":4,"path":"api/tags/Fuzz.json"}],"author":{"name":"Clock","slug":"clock","avatar":"https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20220720/clocklogo.jpg","link":"https://rainsec.cn","description":"","socials":{}}},{"title":"灵活的修改Burp请求","uid":"49976eacba4bfec6b25d67dd692a855b","slug":"灵活的修改Burp请求","date":"2022-03-05T10:38:45.000Z","updated":"2023-04-11T11:38:07.665Z","comments":true,"path":"api/articles/灵活的修改Burp请求.json","cover":"https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20220720/burp.png","text":"灵活的修改Burp请求 在日常渗透测试中经常会遇到请求头需要替换、请求或响应内容需要解密等一系列麻烦的事。更换请求头可以通过Burp的Match and Replace功能来实现，加解密也有一些插件可以实现，但是它们普遍存在着以下缺陷： 自定义数据不能进行保存 加解密不能灵活的指定位置 带着这些需求，笔者在寻找工具时发现了一款有趣的插件Python Scripter: https://github.com/PortSwigger/python-scripter 简介 与其说这是一个插件，不如说其...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"渗透测试","slug":"渗透测试","count":10,"path":"api/categories/渗透测试.json"}],"tags":[{"name":"BurpSuite","slug":"BurpSuite","count":2,"path":"api/tags/BurpSuite.json"}],"author":{"name":"Noel","slug":"noel","avatar":"https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20220211/noel.47xsfyg7vt40.webp","link":"https://rainsec.cn","description":"","socials":{}}},{"title":"容器进程切换漏洞","uid":"2f1f68ab5dfcea1c92e15793016ea760","slug":"容器进程切换漏洞","date":"2022-02-13T10:48:45.000Z","updated":"2023-04-11T11:38:15.281Z","comments":true,"path":"api/articles/容器进程切换漏洞.json","cover":"https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20220720/docker.3x87dx4ktik0.png","text":"容器进程切换思考前置技术Magic Link​ /proc/目录下存在很多的链接文件，但是在Linux 也存在一种特殊的链接文件，这种文件的大小为0，我们知道普通的链接文件的大小等于链接目标的文件路径长度，但是Magic Link的大小为0，它们在打开方式上面也存在差别，普通链接文件会解析出链接文件的路径然后进行打开操作，但是Magic LInk的话不会这样，它会调用内核专门的处理函数，然后返回目标文件的文件描述符。 匿名文件​ Linux Anonymous Files，也叫匿名文件，匿名文件...","link":"","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[{"name":"容器安全","slug":"容器安全","count":1,"path":"api/categories/容器安全.json"}],"tags":[{"name":"容器安全","slug":"容器安全","count":1,"path":"api/tags/容器安全.json"}],"author":{"name":"Clock","slug":"clock","avatar":"https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20220720/clocklogo.jpg","link":"https://rainsec.cn","description":"","socials":{}}},{"title":"RealWorld CTF之qiling框架分析","uid":"c240e7132c70272bfb31ce1eb51c281b","slug":"Qilin框架分析","date":"2022-01-28T10:48:45.000Z","updated":"2023-04-11T11:39:57.249Z","comments":true,"path":"api/articles/Qilin框架分析.json","cover":"https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20220720/realworld.png","text":"RealWorld CTF之qiling框架分析qiling​当时题目就给了一个qiling的使用的用例，甚至和官方文档上面的用例差不多因此肯定是库的问题。 #!/usr/bin/env python3 import os import sys import base64 import tempfile # pip install qiling==1.4.1 from qiling import Qiling def my_sandbox(path, rootfs): ql = Qiling([...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[{"name":"CTF","slug":"CTF","count":1,"path":"api/categories/CTF.json"},{"name":"容器安全","slug":"CTF/容器安全","count":1,"path":"api/categories/CTF/容器安全.json"}],"tags":[{"name":"CTF","slug":"CTF","count":1,"path":"api/tags/CTF.json"}],"author":{"name":"Clock","slug":"clock","avatar":"https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20220720/clocklogo.jpg","link":"https://rainsec.cn","description":"","socials":{}}},{"title":"PHP-Parser的基本使用","uid":"1c56be85ceb7e858a4dda415a10ab942","slug":"PHP-Parser","date":"2022-01-28T10:38:45.000Z","updated":"2023-04-11T11:39:52.109Z","comments":true,"path":"api/articles/PHP-Parser.json","cover":"https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20220720/parsercover.png","text":"PHP-ParserPHP-Parser组件的基础使用，该组件为静态分析和反混淆常用的第三方依赖。 What is PHP-ParserPHP-Parser是nikic用PHP编写的PHP5.2到PHP7.4解析器，其目的是简化静态代码分析和操作 PHP-Parser的基础使用这里先贴一下官方文档 PHP-Parser/doc at master · nikic/PHP-Parser (github.com) 最基本的是要理解其中Walking the AST的部分 初始化解析器首先创建实例 u...","link":"","photos":[],"count_time":{"symbolsCount":"7.1k","symbolsTime":"6 mins."},"categories":[{"name":"漏洞挖掘","slug":"漏洞挖掘","count":6,"path":"api/categories/漏洞挖掘.json"}],"tags":[{"name":"PHP","slug":"PHP","count":1,"path":"api/tags/PHP.json"}],"author":{"name":"Zitui","slug":"zitui","avatar":"https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20220720/zitui_logo.jpg","link":"https://rainsec.cn","description":"","socials":{}}}]}