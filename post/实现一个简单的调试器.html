
<!DOCTYPE html>
<html lang="en" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>实现一个简单的调试器 - RainSec</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="RainSec,"> 
    <meta name="description" content="致力于云原生安全和自动化渗透测试的研究与分享,实现一个简单的调试器​    以经典的GDB为例其项目代码共有十几万行代码，但是很多情况下只会使用到几个常用功能：单步，断点，查看变量，线程/进程切换。而GDB基本上是依赖于ptrace系统调用，主,"> 
    <meta name="author" content="RainSec"> 
    <link rel="alternative" href="atom.xml" title="RainSec" type="application/atom+xml"> 
    <link rel="icon" href="https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20220714/logo.jpg"> 
    
<link rel="stylesheet" href="//at.alicdn.com/t/font_1429596_nzgqgvnmkjb.css">

    
<link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.7.2/animate.min.css">

    
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css">

    
<link rel="stylesheet" href="//cdn.bootcss.com/codemirror/5.48.4/codemirror.min.css">

    
<link rel="stylesheet" href="//cdn.bootcss.com/codemirror/5.48.4/theme/dracula.css">

    
<link rel="stylesheet" href="/css/obsidian.css">

    
<link rel="stylesheet" href="/css/ball-atom.min.css">

    
    
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css">

    
    <script>var musiclist = ""</script>
    
<script src="/js/loadaplayer.js"></script>

    <!-- 引用依赖 -->
    
<link rel="stylesheet" href="/aplayer/dist/APlayer.min.css">

    
<script src="/aplayer/dist/APlayer.min.js"></script>
<script src="/js/Meting.min.js"></script>

    
<meta name="generator" content="Hexo 6.0.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>


<body class="loading">
    <div class="loader">
        <div class="la-ball-atom la-2x">
            <div></div>
            <div></div>
            <div></div>
            <div></div>
        </div>
    </div>
    <span id="config-title" style="display:none">RainSec</span>
    <div id="loader"></div>
    <div id="single">
    <div class="scrollbar gradient-bg-rev"></div>
<div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <div class="navigation animated fadeIn fast delay-1s">
        <img id="home-icon" class="icon-home" src="https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20220714/logo.jpg" alt="" data-url="https://rainsec.cn">
        <div id="play-icon" title="Play/Pause" class="iconfont icon-play"></div>
        <h3 class="subtitle">实现一个简单的调试器</h3>
        <div class="social">
            <!--        <div class="like-icon">-->
            <!--            <a href="javascript:;" class="likeThis active"><span class="icon-like"></span><span class="count">76</span></a>-->
            <!--        </div>-->
            <div>
                <div class="share">
                    
                        <a href="javascript:;" class="iconfont icon-share1"></a>
                        <div class="share-component-cc" data-disabled="facebook,douban,linkedin,diandian,tencent,google"></div>
                    
                </div>
            </div>
        </div>
    </div>
</div>

    <div class="section">
        <div class=article-header-wrapper>
    <div class="article-header">
        <div class="article-cover animated fadeIn" style="
            animation-delay: 600ms;
            animation-duration: 1.2s;
            background-image: 
                radial-gradient(ellipse closest-side, rgba(0, 0, 0, 0.65), #100e17),
                url('https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20230223/image.4ftnu4l1g540.png') ">
        </div>
        <div class="else">
            <p class="animated fadeInDown">
                
                <a href="/categories/二进制"><b>「
                    </b>二进制<b> 」</b></a>
                
                February 23, 2023
            </p>
            <h3 class="post-title animated fadeInDown"><a href="/post/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E8%B0%83%E8%AF%95%E5%99%A8.html" title="实现一个简单的调试器" class="">实现一个简单的调试器</a>
            </h3>
            
            <p class="post-count animated fadeInDown">
                
                <span>
                    <b class="iconfont icon-text2"></b> <i>Words count</i>
                    43k
                </span>
                
                
                <span>
                    <b class="iconfont icon-timer__s"></b> <i>Reading time</i>
                    39 mins.
                </span>
                
                
                
                <span id="busuanzi_container_page_pv">
                    <b class="iconfont icon-read"></b> <i>Read count</i>
                    <span id="busuanzi_value_page_pv">0</span>
                </span>
                
            </p>
            
            
            <ul class="animated fadeInDown post-tags-list" itemprop="keywords"><li class="animated fadeInDown post-tags-list-item"><a class="animated fadeInDown post-tags-list-link" href="/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/" rel="tag">二进制</a></li></ul>
            
        </div>
    </div>
</div>

<div class="screen-gradient-after">
    <div class="screen-gradient-content">
        <div class="screen-gradient-content-inside">
            <div class="bold-underline-links screen-gradient-sponsor">
                <p>
                    <span class="animated fadeIn delay-1s"></span>
                </p>
            </div>
        </div>
    </div>
</div>

<div class="article">
    <div class='main'>
        <div class="content markdown animated fadeIn">
            <h1 id="实现一个简单的调试器"><a href="#实现一个简单的调试器" class="headerlink" title="实现一个简单的调试器"></a>实现一个简单的调试器</h1><p>​    以经典的GDB为例其项目代码共有十几万行代码，但是很多情况下只会使用到几个常用功能：单步，断点，查看变量，线程/进程切换。而GDB基本上是依赖于<code>ptrace</code>系统调用，主要用于编写调试程序。大部分实现思路参考<a target="_blank" rel="noopener" href="https://blog.tartanllama.xyz/writing-a-linux-debugger-breakpoints/">Writing a Linux Debugger Part 2: Breakpoints (tartanllama.xyz)</a>系列文章，强烈推荐阅读</p>
<p>目标功能：</p>
<ul>
<li>单步</li>
<li>断点</li>
<li>查看内存/寄存器</li>
<li>查看汇编</li>
</ul>
<h1 id="ptrace-原理"><a href="#ptrace-原理" class="headerlink" title="ptrace 原理"></a>ptrace 原理</h1><p>​    先来看看ptrace系统调用的函数签名：</p>
<pre><code class="c">#include &lt;sys/ptrace.h&gt;

long ptrace(enum __ptrace_request request, pid_t pid, void *addr, void *data);
/*DESCRIPTION
       The  ptrace()  system  call  provides  a  means  by  which one process (the
       "tracer") may observe and control the execution  of  another  process  (the
       "tracee"), and examine and change the tracee's memory and registers.  It is
       primarily used to implement breakpoint debugging and system call tracing.
       即ptrace系统调用提供给tracer控制，读取，修改另一个进程(tracee)的能力，由此可以实现断点和系统调用追踪
       
       A tracee first needs to be attached to the tracer.  Attachment  and  subse‐
       quent commands are per thread: in a multithreaded process, every thread can
       be individually attached to a (potentially different) tracer, or  left  not
       attached  and  thus  not debugged.  Therefore, "tracee" always means "(one)
       thread", never "a (possibly multithreaded) process".  Ptrace  commands  are
       always sent to a specific tracee using a call of the form
       即tracer通过ptrace进行附加(attach)和发送命令都是针对某一个线程的而不是进程
*/
</code></pre>
<ul>
<li>request：调试者(<strong>tracer</strong>)要执行的操作，常见的有PTRACE_TRACEME，PTRACE_ATTACH，PTRACE_PEEKUSER，PTRACE_SINGLESTEP等</li>
<li>pid：被调试进程(<strong>tracee</strong>)pid</li>
<li>addr：要读写的内存地址</li>
<li>data：如果要向目标进程写入数据那么data就是我们数据地址；如果要读取目标进程数据那么data就是保留数据的地址</li>
</ul>
<p>ptrace系统调用会根据不同的request完成不同功能如：</p>
<ul>
<li>PTRACE_TRACEME：表示此进程即将被父进程trace，此时其他参数被忽略</li>
<li>PTRACE_PEEKTEXT, PTRACE_PEEKDATA：读取tracee在<strong>addr</strong>(虚拟内存空间)处的一个字，返回值就是读取到的字</li>
<li>PTRACE_PEEKUSER：读取tracee的<strong>USER area</strong>，其包含了该进程的寄存器以及其他信息</li>
<li>PTRACE_POKETEXT, PTRACE_POKEDATA：复制<strong>data</strong>所指向的一个字到tracee的<strong>addr</strong>(虚拟内存空间)处</li>
<li>PTRACE_POKEUSER：复制data所指的一个字带tracee的<strong>USER area</strong></li>
<li>PTRACE_GETREGS, PTRACE_GETFPREGS：复制<strong>tracee</strong>的<code>通用寄存器</code>或者<code>浮点寄存器</code>到<strong>tracer</strong>的<strong>data</strong>所指的位置，addr被忽略</li>
<li>PTRACE_SETREGS, PTRACE_SETFPREGS：修改tracee的通用寄存器或者浮点寄存器</li>
<li>PTRACE_CONT：运行被暂停的tracee进程。如果data参数非0那么就表示data是传给tracee的<strong>信号数值</strong></li>
<li>PTRACE_SYSCALL, PTRACE_SINGLESTEP：运行被暂停的tracee进程就像PTRACE_CONT功能，不同的是PTRACE_SYSCALL表示运行到下一个系统调用(进入或返回)，PTRACE_SINGLESTEP表示仅运行一条指令便停止</li>
</ul>
<p>以下是Linux-2.4.16内核的ptrace系统调用内部实现源码：</p>
<pre><code class="c">asmlinkage int sys_ptrace(long request, long pid, long addr, long data)        //asmlinkage是指明该函数用堆栈来传递参数
{
    struct task_struct *child;
    struct user * dummy = NULL;
    int i, ret;

    lock_kernel();
    ret = -EPERM;
    if (request == PTRACE_TRACEME) {        /*检查traced状态是否重复*/
        /* are we already being traced? */
        if (current-&gt;ptrace &amp; PT_PTRACED)
            goto out;
        /* set the ptrace bit in the process flags. */
        current-&gt;ptrace |= PT_PTRACED;        //current指向当前进程(task_struct)，因此PTRACE_TRACEME将当前进程设置为PT_PTRACED状态(traced)即被trace者(tracee)
        ret = 0;
        goto out;
    }
    ret = -ESRCH;
    read_lock(&amp;tasklist_lock);                //调度链表上读锁
    child = find_task_by_pid(pid);            //获取目标pid进程结构体(task_struct)
    if (child)
        get_task_struct(child);
    read_unlock(&amp;tasklist_lock);
    if (!child)
        goto out;

    ret = -EPERM;
    if (pid == 1)        /* you may not mess with init */
        goto out_tsk;
    /*就像gdb有直接启动并调试一个程序和附加一个进程并调试两个功能，也是基于ptrace的PTRACE_ATTACH让目标进程处于traced状态*/
    if (request == PTRACE_ATTACH) {
        ret = ptrace_attach(child);
        goto out_tsk;
    }

    ...
    /*这就是ptrace的主体，通过switch case和request完成，这里先了解部分*/
    switch (request) {
    /* when I and D space are separate, these will need to be fixed. */
    /*PTRACE_PEEKTEXT，PTRACE_PEEKDATA功能相同都是从虚拟地址addr中读取数据到data指针中*/
    case PTRACE_PEEKTEXT: /* read word at location addr. */ 
    case PTRACE_PEEKDATA: {
        unsigned long tmp;
        int copied;

        copied = access_process_vm(child, addr, &amp;tmp, sizeof(tmp), 0);
        ret = -EIO;
        if (copied != sizeof(tmp))
            break;
        ret = put_user(tmp,(unsigned long *) data);
        break;
    }

    /* read the word at location addr in the USER area. */
    /*可以检查用户态内存区域(USER area),从USER区域中读取一个字节，偏移量为addr*/
    case PTRACE_PEEKUSR: {
        unsigned long tmp;

        ret = -EIO;
        if ((addr &amp; 3) || addr &lt; 0 || 
            addr &gt; sizeof(struct user) - 3)
            break;

        tmp = 0;  /* Default return condition */
        if(addr &lt; FRAME_SIZE*sizeof(long))
            tmp = getreg(child, addr);
        if(addr &gt;= (long) &amp;dummy-&gt;u_debugreg[0] &amp;&amp;
           addr &lt;= (long) &amp;dummy-&gt;u_debugreg[7]){
            addr -= (long) &amp;dummy-&gt;u_debugreg[0];
            addr = addr &gt;&gt; 2;
            tmp = child-&gt;thread.debugreg[addr];
        }
        ret = put_user(tmp,(unsigned long *) data);
        break;
    }

    /* when I and D space are separate, this will have to be fixed. */
    /*PTRACE_POKETEXT和PTRACE_POKEDATA功能相同都是向虚拟地址addr写入来自data的数据*/
    case PTRACE_POKETEXT: /* write the word at location addr. */
    case PTRACE_POKEDATA:
        ret = 0;
        if (access_process_vm(child, addr, &amp;data, sizeof(data), 1) == sizeof(data))
            break;
        ret = -EIO;
        break;

    case PTRACE_POKEUSR: /* write the word at location addr in the USER area */
        ret = -EIO;
        if ((addr &amp; 3) || addr &lt; 0 || 
            addr &gt; sizeof(struct user) - 3)
            break;

        if (addr &lt; FRAME_SIZE*sizeof(long)) {
            ret = putreg(child, addr, data);
            break;
        }
        /* We need to be very careful here.  We implicitly
           want to modify a portion of the task_struct, and we
           have to be selective about what portions we allow someone
           to modify. */

          ret = -EIO;
          if(addr &gt;= (long) &amp;dummy-&gt;u_debugreg[0] &amp;&amp;
             addr &lt;= (long) &amp;dummy-&gt;u_debugreg[7]){

              if(addr == (long) &amp;dummy-&gt;u_debugreg[4]) break;
              if(addr == (long) &amp;dummy-&gt;u_debugreg[5]) break;
              if(addr &lt; (long) &amp;dummy-&gt;u_debugreg[4] &amp;&amp;
                 ((unsigned long) data) &gt;= TASK_SIZE-3) break;
              
              if(addr == (long) &amp;dummy-&gt;u_debugreg[7]) {
                  data &amp;= ~DR_CONTROL_RESERVED;
                  for(i=0; i&lt;4; i++)
                      if ((0x5f54 &gt;&gt; ((data &gt;&gt; (16 + 4*i)) &amp; 0xf)) &amp; 1)
                          goto out_tsk;
              }

              addr -= (long) &amp;dummy-&gt;u_debugreg;
              addr = addr &gt;&gt; 2;
              child-&gt;thread.debugreg[addr] = data;
              ret = 0;
          }
          break;
    /*都是让tracee继续运行，只是啥时候停止不同*/
    case PTRACE_SYSCALL: /* continue and stop at next (return from) syscall */
    case PTRACE_CONT: { /* restart after signal. */
        long tmp;

        ret = -EIO;
        if ((unsigned long) data &gt; _NSIG)    //data为tracer传给tracee的信号数值，这里检查范围
            break;
        if (request == PTRACE_SYSCALL)
            child-&gt;ptrace |= PT_TRACESYS;    //设置PT_TRACESYS标志，为了在下一个系统调用处停止
        else
            child-&gt;ptrace &amp;= ~PT_TRACESYS;    //清除PT_TRACESYS标志，不停止
        child-&gt;exit_code = data;
    /* make sure the single step bit is not set. 清除EFLAGS的单步标志(Trap Flag)*/
        tmp = get_stack_long(child, EFL_OFFSET) &amp; ~TRAP_FLAG;
        put_stack_long(child, EFL_OFFSET,tmp);
        wake_up_process(child);                //唤醒进程
        ret = 0;
        break;
    }

/*
 * make the child exit.  Best I can do is send it a sigkill. 
 * perhaps it should be put in the status that it wants to 
 * exit.
 */
    case PTRACE_KILL: {
        long tmp;

        ret = 0;
        if (child-&gt;state == TASK_ZOMBIE)    /* already dead */
            break;
        child-&gt;exit_code = SIGKILL;
        /* make sure the single step bit is not set. */
        tmp = get_stack_long(child, EFL_OFFSET) &amp; ~TRAP_FLAG;
        put_stack_long(child, EFL_OFFSET, tmp);
        wake_up_process(child);
        break;
    }
    /*设置单步运行很简单只需将eflags的Trap Flag置1即可*/
    case PTRACE_SINGLESTEP: {  /* set the trap flag. */
        long tmp;

        ret = -EIO;
        if ((unsigned long) data &gt; _NSIG)
            break;
        child-&gt;ptrace &amp;= ~PT_TRACESYS;
        if ((child-&gt;ptrace &amp; PT_DTRACE) == 0) {
            /* Spurious delayed TF traps may occur */
            child-&gt;ptrace |= PT_DTRACE;
        }
        tmp = get_stack_long(child, EFL_OFFSET) | TRAP_FLAG;    //Trap Flag置1
        put_stack_long(child, EFL_OFFSET, tmp);
        child-&gt;exit_code = data;
        /* give it a chance to run. */
        wake_up_process(child);
        ret = 0;
        break;
    }

    case PTRACE_DETACH:
        /* detach a process that was attached. */
        ret = ptrace_detach(child, data);
        break;
    /*读取所有通用寄存器值*/
    case PTRACE_GETREGS: { /* Get all gp regs from the child. */
          if (!access_ok(VERIFY_WRITE, (unsigned *)data, FRAME_SIZE*sizeof(long))) {
            ret = -EIO;
            break;
        }
        for ( i = 0; i &lt; FRAME_SIZE*sizeof(long); i += sizeof(long) ) {
            __put_user(getreg(child, i),(unsigned long *) data);
            data += sizeof(long);
        }
        ret = 0;
        break;
    }
    /*设置所有通用寄存器值*/
    case PTRACE_SETREGS: { /* Set all gp regs in the child. */
        unsigned long tmp;
          if (!access_ok(VERIFY_READ, (unsigned *)data, FRAME_SIZE*sizeof(long))) {
            ret = -EIO;
            break;
        }
        for ( i = 0; i &lt; FRAME_SIZE*sizeof(long); i += sizeof(long) ) {
            __get_user(tmp, (unsigned long *) data);
            putreg(child, i, tmp);
            data += sizeof(long);
        }
        ret = 0;
        break;
    }
    /*获取浮点寄存器值*/
    case PTRACE_GETFPREGS: { /* Get the child FPU state. */
        if (!access_ok(VERIFY_WRITE, (unsigned *)data,
                   sizeof(struct user_i387_struct))) {
            ret = -EIO;
            break;
        }
        ret = 0;
        if ( !child-&gt;used_math ) {
            /* Simulate an empty FPU. */
            set_fpu_cwd(child, 0x037f);
            set_fpu_swd(child, 0x0000);
            set_fpu_twd(child, 0xffff);
        }
        get_fpregs((struct user_i387_struct *)data, child);
        break;
    }
    /*设置浮点寄存器值*/
    case PTRACE_SETFPREGS: { /* Set the child FPU state. */
        if (!access_ok(VERIFY_READ, (unsigned *)data,
                   sizeof(struct user_i387_struct))) {
            ret = -EIO;
            break;
        }
        child-&gt;used_math = 1;
        set_fpregs(child, (struct user_i387_struct *)data);
        ret = 0;
        break;
    }

    case PTRACE_GETFPXREGS: { /* Get the child extended FPU state. */
        ...
    }

    case PTRACE_SETFPXREGS: { /* Set the child extended FPU state. */
        ...
    }

    case PTRACE_SETOPTIONS: {
        if (data &amp; PTRACE_O_TRACESYSGOOD)
            child-&gt;ptrace |= PT_TRACESYSGOOD;
        else
            child-&gt;ptrace &amp;= ~PT_TRACESYSGOOD;
        ret = 0;
        break;
    }

    default:
        ret = -EIO;
        break;
    }
out_tsk:
    free_task_struct(child);
out:
    unlock_kernel();
    return ret;
}
</code></pre>
<p>注意这个函数<code>get_stack_long(proccess, offset)</code>：</p>
<pre><code class="c">/*
 * this routine will get a word off of the processes privileged stack. 
 * the offset is how far from the base addr as stored in the TSS.  
 * this routine assumes that all the privileged stacks are in our
 * data space.
 */   
static inline int get_stack_long(struct task_struct *task, int offset)
{
    unsigned char *stack;

    stack = (unsigned char *)task-&gt;thread.esp0;
    stack += offset;
    return (*((int *)stack));
}
</code></pre>
<p>其中task-&gt;thread.esp0是堆栈指针，通用的寄存器在堆栈中按顺序排放，通过偏移量0ffset便可以依次读取</p>
<h2 id="PTRACE-TRACEME"><a href="#PTRACE-TRACEME" class="headerlink" title="PTRACE_TRACEME"></a>PTRACE_TRACEME</h2><p>​    当要调试一个进程时需要其进入被追踪状态(traced)，有两种方法进入该状态：</p>
<ul>
<li>被调试进程<strong>主动</strong>调用<code>ptrace(PTRACE_TRACEME, ...)</code>进入traced状态</li>
<li>调试进程调用<code>ptrace(PTRACE_ATTACH, pid, ...)</code>来使指定进程进入</li>
</ul>
<p> 总之被调试进程必须进入traced状态才能进行调试，因为Linux会对处于traced状态的进程进行特殊操作。以第一种方式来说明：</p>
<pre><code class="c">if (request == PTRACE_TRACEME) {
        /* are we already being traced? */
        if (current-&gt;ptrace &amp; PT_PTRACED)
            goto out;
        /* set the ptrace bit in the process flags. */
        current-&gt;ptrace |= PT_PTRACED;
        ret = 0;
        goto out;
    }
</code></pre>
<p>​    只是将当前进程标记为<strong>PT_PTRACED</strong>状态，但是如果该进程接下来进行<strong>execve</strong>系统调用去执行一个外部程序时会<strong>暂停当前进程</strong>，并且发送<strong>SIGCHLD</strong>信号给<strong>父进程</strong>，父进程接收到该信号时就可以对被调试进程进行调试。</p>
<p><strong>sys_execve() -&gt; do_execve() -&gt; load_elf_binary()：</strong></p>
<pre><code class="c">static int load_elf_binary(struct linux_binprm * bprm, struct pt_regs * regs)
{
    ...
    if (current-&gt;ptrace &amp; PT_PTRACED)
        send_sig(SIGTRAP, current, 0);
    ...
}
</code></pre>
<p>对于处于traced状态的进程执行<strong>execve</strong>系统调用时会发送一个<strong>SIGTRAP给当前进程</strong>。这个信号将在<code>do_signal</code>函数处理：</p>
<pre><code class="c">int do_signal(struct pt_regs *regs, sigset_t *oldset) 
{
    for (;;) {
        unsigned long signr;

        spin_lock_irq(&amp;current-&gt;sigmask_lock);
        signr = dequeue_signal(&amp;current-&gt;blocked, &amp;info);
        spin_unlock_irq(&amp;current-&gt;sigmask_lock);

        // 如果进程被标记为 PTRACE 状态
        if ((current-&gt;ptrace &amp; PT_PTRACED) &amp;&amp; signr != SIGKILL) {    //除了SIGKILL信号，都将让tracee停止并通知tracer
            /* 让调试器运行  */
            current-&gt;exit_code = signr;
            current-&gt;state = TASK_STOPPED;   // 让自己进入停止运行状态
            notify_parent(current, SIGCHLD); // 发送 SIGCHLD 信号给父进程表示子进程"死亡(被替换)"
            schedule();                      // 让出CPU的执行权限
            ...
        }
    }
}
</code></pre>
<p>所以调试器使用这种方式调试某个程序时大致例程为：</p>
<p><img src="https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20230223/image-20230129132429982.4su930ro2vq0.png" alt="image-20230129132429982"></p>
<p>当父进程（调试进程）接收到 <code>SIGCHLD</code> 信号后，表示被调试进程已经标记为<strong>被追踪状态并且停止运行</strong>，那么调试进程就可以开始进行调试了。</p>
<h2 id="PTRACE-SINGLESTEP"><a href="#PTRACE-SINGLESTEP" class="headerlink" title="PTRACE_SINGLESTEP"></a>PTRACE_SINGLESTEP</h2><p>​    单步运行是最为常用的，当把tracee设置为单步运行模式时，tracee每执行一条指令CPU都会停止然后向父进程发送一个<strong>SIGCHLD</strong>信号，在ptrace中实现是将eflags设置trap_flag标志位：</p>
<pre><code class="c">case PTRACE_SINGLESTEP: {  /* set the trap flag. */
        long tmp;

        ret = -EIO;
        if ((unsigned long) data &gt; _NSIG)
            break;
        child-&gt;ptrace &amp;= ~PT_TRACESYS;
        if ((child-&gt;ptrace &amp; PT_DTRACE) == 0) {
            /* Spurious delayed TF traps may occur */
            child-&gt;ptrace |= PT_DTRACE;
        }
        tmp = get_stack_long(child, EFL_OFFSET) | TRAP_FLAG;
        put_stack_long(child, EFL_OFFSET, tmp);
        child-&gt;exit_code = data;
        /* give it a chance to run. */
        wake_up_process(child);
        ret = 0;
        break;
    }
</code></pre>
<p>​    能够这样做是基于X86 intel CPU提供一个硬件机制，就是当eflags的<code>Trap Flag</code>置为1时，CPU每执行一条指令都会产生一个异常然后Linux异常处理机制进程处理，由此会发送一个<strong>SIGTRAP</strong>信号给<strong>tracee</strong>；核心是：</p>
<pre><code class="c">tmp = get_stack_long(child, EFL_OFFSET) | TRAP_FLAG;
put_stack_long(child, EFL_OFFSET, tmp);
</code></pre>
<ol>
<li>获取进程的 <code>eflags</code> 寄存器的值，并且设置 <code>Trap Flag</code> 标志。</li>
<li>把新的值设置到进程的 <code>eflags</code> 寄存器中。</li>
</ol>
<p>设置完寄存器后唤醒(wake_up_process)进程，让其进入运行状态：</p>
<p><img src="https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20230223/image-20230129132429982.4su930ro2vq0.png" alt="image-20230129132429982"></p>
<p>​    同样的当tracee执行完一条指令获取<strong>SIGTRAP</strong>信号，在<strong>do_signal</strong>函数处理信号时，由于<code>current-&gt;ptrace &amp; PT_PTRACED</code>将停止执行并发送<strong>SIGCHLD</strong>信号给父进程tracer。父进程接收到SIGCHLD信号后就知道tracee停止，可以发送命令来读取或者修改tracee的内存数据或寄存器，或者通过调用 <code>ptrace(PTRACE_CONT, child,...)</code> 来让被调试进程进行运行等</p>
<h1 id="Debugger-基本功能实现"><a href="#Debugger-基本功能实现" class="headerlink" title="Debugger 基本功能实现"></a>Debugger 基本功能实现</h1><p>​    实现一个简单的debugger，大致模型如下：主程序fork一个子程序去执行待调试程序；然后主程序循环等待用户输入命令，停止主程序停止并等待输入命令的条件就是子程序停止，这会在<strong>首次execute一个程序</strong>发生，以及<strong>单步(PTRACE_SINGLESTEP)<strong>或者</strong>断点</strong>发生。子程序很简单只需要调用execute系统调用启动一个新程序即可</p>
<p><img src="https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20230223/image-20230208214054408.2e6f4s8cndog.png" alt="image-20230208214054408"></p>
<p>待实现的debugger有三个基本功能：单步，读写寄存器，读写内存。基于这三个功能再添加其他类似于gdb的功能。初始框架如下：</p>
<pre><code class="c">int main(int argc, char *argv[]){
    if(argc &lt; 2){
        fprintf(stderr, "Expecting program name.\n");
        return -1;
    }

    const char *name = argv[1];
    pid_t pid = fork();
    if(pid == 0){
        //child process
        //execute tracee
        ptrace(PTRACE_TRACEME, 0, 0, 0);
        execl(name, name, NULL, NULL);
    }else if(pid &gt; 0){
        //parent process
        //execute tracer
    }else{
        perror("fork.");
        return -1;
    }

    return 0;
}
</code></pre>
<p>子程序部分很简单调用exec族函数即可。</p>
<h2 id="Parent"><a href="#Parent" class="headerlink" title="Parent"></a>Parent</h2><p>​    首先考虑使用一个结构体记录子进程的信息，然后父进程进入一个读取用户命令的循环，这里使用<a target="_blank" rel="noopener" href="https://github.com/antirez/linenoise">linenoise</a>开源项目实现命令补全，命令记录等功能当然还需要处理命令：</p>
<pre><code class="c">/**
 * debugger uitls
*/
typedef struct Debugger{
    const char *d_name;
    int d_pid;
    Breakpoint *d_brks;            //记录断点
}Debugger;
void dbg_run(Debugger *dbg){
    int wait_status;
    char *cmd;
    waitpid(dbg-&gt;d_pid, &amp;wait_status, 0);
    /*UI for start up*/
    while((cmd = linenoise("minidbg$ ")) != NULL){
        dbg_handle_command(dbg, cmd);
        linenoiseHistoryAdd(cmd);
        linenoiseFree(cmd);
    }
}
</code></pre>
<p>​    使用Debugger结构体记录程序状态，主要是子程序pid和之后的断点信息；<code>linenoise("minidbg$ ")</code>会打印<code>minidbg$ </code>并等待输入，使用<code>dbg_handle_command</code>处理命令包括读写内存，寄存器，下断点等。<code>linenoiseHistoryAdd(cmd)</code>将命令添加到历史记录中</p>
<p>在<code>dbg_handle_command</code>函数中大致结构为：很方便添加新功能，<strong>is_prefix</strong>辅助函数用于判断缩写指令</p>
<pre><code class="c">void dbg_handle_command(Debugger *dbg, char *cmd){
    char *lcmd = strdup(cmd);
    char *argv[8] = { 0 };    
    char *command;

    argv[0] = strtok(lcmd, " ");
    for(int i = 1; i &lt; 8; i++){
        argv[i] = strtok(NULL, " ");
        if(argv[i] == NULL) break;
    }
    command = argv[0];
    if(command == NULL) return;
    if(is_prefix(command, "continue")){
        /*do_command*/
    }
    else{
        fprintf(stderr, "Unkown command: %s.\n", command);
    }

    return free(lcmd);
}

bool is_prefix(char *s, const char *ss){
    if(s == NULL || ss == NULL) return false;
    if(strlen(s) &gt; strlen(ss)) return false;
    
    return !strncmp(s, ss, strlen(s));
}
</code></pre>
<h2 id="读写寄存器"><a href="#读写寄存器" class="headerlink" title="读写寄存器"></a>读写寄存器</h2><p>​    一个非常基础的功能，基于<code>ptrace(PTRACE_GETREGS, ...)</code>和<code>ptrace(PTRACE_SETREGS, ...)</code>读写寄存器，为了保留寄存器信息在**&lt;sys/user.h&gt;**头文件中定义了如下结构体：</p>
<pre><code class="c">struct user_regs_struct
{
  __extension__ unsigned long long int r15;
  __extension__ unsigned long long int r14;
  __extension__ unsigned long long int r13;
  __extension__ unsigned long long int r12;
  __extension__ unsigned long long int rbp;
  __extension__ unsigned long long int rbx;
  __extension__ unsigned long long int r11;
  __extension__ unsigned long long int r10;
  __extension__ unsigned long long int r9;
  __extension__ unsigned long long int r8;
  __extension__ unsigned long long int rax;
  __extension__ unsigned long long int rcx;
  __extension__ unsigned long long int rdx;
  __extension__ unsigned long long int rsi;
  __extension__ unsigned long long int rdi;
  __extension__ unsigned long long int orig_rax;
  __extension__ unsigned long long int rip;
  __extension__ unsigned long long int cs;
  __extension__ unsigned long long int eflags;
  __extension__ unsigned long long int rsp;
  __extension__ unsigned long long int ss;
  __extension__ unsigned long long int fs_base;
  __extension__ unsigned long long int gs_base;
  __extension__ unsigned long long int ds;
  __extension__ unsigned long long int es;
  __extension__ unsigned long long int fs;
  __extension__ unsigned long long int gs;
};
</code></pre>
<p>配合ptrace可以直接按照以上结构体读写寄存器，所以一次读写至少是所有通用寄存器。根据结构体排序定义了如下数据结构体来记录寄存器信息：</p>
<pre><code class="c">/*utils.h*/
enum reg{
    en_rax, en_rbx, en_rcx, en_rdx,
    en_rdi, en_rsi, en_rbp, en_rsp,
    en_r8,  en_r9,  en_r10, en_r11,
    en_r12, en_r13, en_r14, en_r15,
    en_rip, en_rflags,    en_cs,
    en_orig_rax, en_fs_base,
    en_gs_base,
    en_fs, en_gs, en_ss, en_ds, en_es
};

struct reg_descriptor {
    enum reg r;
    char *name;
};
/*utils.c*/
const size_t n_regs = 27;
const struct reg_descriptor g_register_descriptors[] = {
    { en_r15, "r15" },
    { en_r14, "r14" },
    { en_r13, "r13" },
    { en_r12, "r12" },
    { en_rbp, "rbp" },
    { en_rbx, "rbx" },
    { en_r11, "r11" },
    { en_r10, "r10" },
    { en_r9, "r9" },
    { en_r8, "r8" },
    { en_rax, "rax" },
    { en_rcx, "rcx" },
    { en_rdx, "rdx" },
    { en_rsi, "rsi" },
    { en_rdi, "rdi" },
    { en_orig_rax, "orig_rax" },
    { en_rip, "rip" },
    { en_cs, "cs" },
    { en_rflags, "eflags" },
    { en_rsp, "rsp" },
    { en_ss, "ss" },
    { en_fs_base, "fs_base" },
    { en_gs_base, "gs_base" },
    { en_ds, "ds" },
    { en_es, "es" },
    { en_fs, "fs" },
    { en_gs, "gs" }
};
</code></pre>
<p>因为只能一次读写所有寄存器，因此要读写某个寄存器时先用ptrace把所有的读取出来在通过寄存器表查找<strong>g_register_descriptors</strong>，并且因为寄存器表和<code>struct user_regs_struct</code>结构体排序一致可以直接用表中的偏移读写结构体：</p>
<pre><code class="c">void set_register_value(pid_t pid, enum reg r, uint64_t value){
    struct user_regs_struct regs;
    int reg_descriptor_idx;
    ptrace(PTRACE_GETREGS, pid, NULL, &amp;regs);

    /*locate reg_r`s index in user_regs_struct struct*/
    reg_descriptor_idx = -1;
    for(int i = 0; i &lt; n_regs; i++){
        if(g_register_descriptors[i].r == r){
            reg_descriptor_idx = i;
            break;
        }
    }

    *(uint64_t *)((uint64_t *)&amp;regs + reg_descriptor_idx) = value;
    ptrace(PTRACE_SETREGS, pid, NULL, &amp;regs);

}

uint64_t get_register_value(pid_t pid, enum reg r){
    struct user_regs_struct regs;
    int reg_descriptor_idx;
    uint64_t ret = 0;
    ptrace(PTRACE_GETREGS, pid, NULL, &amp;regs);

    /*locate reg_r`s index in user_regs_struct struct*/
    reg_descriptor_idx = -1;
    for(int i = 0; i &lt; n_regs; i++){
        if(g_register_descriptors[i].r == r){
            reg_descriptor_idx = i;
            break;
        }
    }

    if(reg_descriptor_idx != -1){
        ret = *(uint64_t *)((uint64_t *)&amp;regs + reg_descriptor_idx);
        return ret;
    }
    printf("[error] get_register_value(%d, %d)\n", pid, r);
    return ret;
}

/*辅助函数*/
char *get_register_name(enum reg r){
    for(int i = 0; i &lt; n_regs; i++){
        if(g_register_descriptors[i].r == r)
            return g_register_descriptors[i].name;
    }
    return NULL;
}

enum reg get_register_from_name(char *name){
    for(int i = 0; i &lt; n_regs; i++){
        if(!strcasecmp(name, g_register_descriptors[i].name)){
            return g_register_descriptors[i].r;
        }
    }
    return -1;      /*-1 is impossible in reg_descriptor-&gt;r*/
}
</code></pre>
<h3 id="读写内存"><a href="#读写内存" class="headerlink" title="读写内存"></a>读写内存</h3><p>​    读写内存和寄存器很类似，但使用ptrace一次性只能读写8字节(64位)：<code>ptrace(PTRACE_PEEKDATA, dbg-&gt;d_pid, address, NULL)</code>需要提供子进程的虚拟内存地址(address)</p>
<pre><code class="c">uint64_t dbg_read_memory(Debugger *dbg, uint64_t address){
    return ptrace(PTRACE_PEEKDATA, dbg-&gt;d_pid, address, NULL);
}

void dbg_write_memory(Debugger *dbg, uint64_t address, uint64_t value){
    ptrace(PTRACE_POKEDATA, dbg-&gt;d_pid, address, value);
}
</code></pre>
<h2 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h2><p>​    断点其实有两种：硬断点和软断点。其中硬断点涉及到CPU架构数量有限比如x86结构提供4个硬件断点(断点寄存器)，但可以检测读写执行三种情况。而软断点通过在指定位置插入<strong>断点指令</strong>，然后程序运行到此处执行断点指令让debugger获取<code>SIGTRAP</code>信号并停止运行，因此软断点可以有无数个；这里主要实现软断点，如x86的断点指令为<code>int 3</code>(机器码 0xcc)，需要考虑断点插入，断点记录，触发断点后如何继续运行等</p>
<p>使用如下结构体存储断点信息：</p>
<pre><code class="c">/**
 * breakpoints utils
*/
typedef struct Breakpoint{
    int b_pid;
    unsigned long b_addr;           //map key
    int b_enabled;
    unsigned char b_saved_data;        //需要保存插入0xcc位置的数据
    UT_hash_handle hh;
}Breakpoint;
</code></pre>
<p>借助[uthash](<a target="_blank" rel="noopener" href="https://github.com/troydhanson/uthash">troydhanson/uthash: C macros for hash tables and more (github.com)</a>)开源项目实现一个hash表来记录断点信息，只需在结构体中包含<strong>UT_hash_handle</strong>成员即可；其提供宏HASH_FIND_PTR：</p>
<pre><code class="c">#define HASH_FIND_PTR(head,findptr,out) HASH_FIND(hh,head,findptr,sizeof(void *),out)
</code></pre>
<p>可以通过结构体中的<strong>b_addr</strong>作为key，其表头在初始化<code>Debugger</code>结构体时设置为NULL即可：</p>
<pre><code class="c">Debugger dbg;
dbg.d_brks = NULL;       /* important! initialize to NULL related to breakpoints` map*/
</code></pre>
<p>然后实现两个断点函数：brk_enable，brk_disable；分别进行插入断点和去除断点：</p>
<pre><code class="c">#include "utils.h"

void brk_enable(Breakpoint *bp){
    unsigned long data = ptrace(PTRACE_PEEKDATA, bp-&gt;b_pid, bp-&gt;b_addr, 0);
    bp-&gt;b_saved_data = data &amp; 0xff;     //save LSB
    data = ((data &amp; ~0xff) | INT3);
    ptrace(PTRACE_POKEDATA, bp-&gt;b_pid, bp-&gt;b_addr, data);
    bp-&gt;b_enabled = 1;
}

void brk_disable(Breakpoint *bp){
    unsigned long data = ptrace(PTRACE_PEEKDATA, bp-&gt;b_pid, bp-&gt;b_addr, 0);
    data = ((data &amp; ~0xff) | bp-&gt;b_saved_data);
    ptrace(PTRACE_POKEDATA, bp-&gt;b_pid, bp-&gt;b_addr, data);
    bp-&gt;b_enabled = 0;
}
</code></pre>
<h2 id="单步"><a href="#单步" class="headerlink" title="单步"></a>单步</h2><p>​    单步运行时除了普通指令，需要考虑是否跳过函数调用(<strong>call</strong>)也就是需要<strong>步过</strong>的情况，还有如果当前为断点处单步时需要格外的断点处理。基于<code>ptrace(PTRACE_SINGLESTEP, ...)</code>单步步入时需要考虑两种情况，涉及断点；其他非断点情况直接<code>PTRACE_SINGLESTEP</code>单步运行即可</p>
<ul>
<li>pc刚好触发一个断点，即执行了<code>0xcc</code></li>
<li>pc即将触发一个断点</li>
</ul>
<p>使用如下函数处理单步命令：</p>
<pre><code class="c">/*we can show UI here*/
void dbg_step_in(Debugger *dbg){
    uint64_t possible_pc = get_pc(dbg) - 1;    /*if this is breakpoint int 3 executed*/
    Breakpoint *bp = NULL;
    HASH_FIND_PTR(dbg-&gt;d_brks, &amp;possible_pc, bp);
    if(bp != NULL &amp;&amp; bp-&gt;b_enabled){
        /*step over breakpoint*/
        brk_disable(bp);
        set_pc(dbg, possible_pc);
        ptrace(PTRACE_SINGLESTEP, dbg-&gt;d_pid, NULL, NULL);
        wait_for_signal(dbg);
        brk_enable(bp);
    }else{
        ptrace(PTRACE_SINGLESTEP, dbg-&gt;d_pid, NULL, NULL);
        wait_for_signal(dbg);
    }

    show_UI(dbg);
}
</code></pre>
<p>但是后来发现一个bug：当断点设置在一个单机器码的指令处时(如 push rbp 0x55)，以上逻辑会陷入死循环，因为每次单步时都会检测<code>pc-1</code>是否为断点；所以得想办法面对单机器码断点的情况避免该逻辑，不可能把所有单机器码指令全列出来然后比对，所以这里使用反编译引擎<strong>capstone</strong>。如果pc-1是个断点那么先判断pc-1处的指令长度是否为1，如果是那么设置一个静态flag表示已经步过一个单机器码的断点下一次单步时不再考虑pc-1：</p>
<pre><code class="c">/**
 * This function invoked in situation:
 * 1.PTRACE_SINGLESTEP the current instruction which maybe inserted a breakpoint OR maybe not
 * 2.already triggered a breakpoint(0xcc) PTRACE_SINGLESTEP the broken instruction
 * we can show UI here
*/
void dbg_step_in(Debugger *dbg){
    static bool one_machine_code_flag = false;
    uint64_t possible_pc, data;
    Breakpoint *bp = NULL;
    csh handle = 0;
    cs_insn* insn;
    size_t count;
    int child_status;

    if(!one_machine_code_flag){
        possible_pc = get_pc(dbg) - 1;          /*if this is breakpoint int 3 executed*/
        HASH_FIND_PTR(dbg-&gt;d_brks, &amp;possible_pc, bp);
        if(bp != NULL &amp;&amp; bp-&gt;b_enabled){
            brk_disable(bp);
            /*check for single machine code instruction*/
            data = ptrace(PTRACE_PEEKDATA, dbg-&gt;d_pid, possible_pc, NULL);  
            if (cs_open(CS_ARCH_X86, CS_MODE_64, &amp;handle)) {
                printf("[error]: Failed to initialize capstone engine!\n");
                exit(-1);
            }
            cs_disasm(handle, (unsigned char*)&amp;data, 8, 0x1000, 1, &amp;insn);
            if(insn-&gt;size == 1){
                one_machine_code_flag = true;
            }else{
                one_machine_code_flag = false;
            }
            set_pc(dbg, possible_pc);
            ptrace(PTRACE_SINGLESTEP, dbg-&gt;d_pid, NULL, NULL);
            wait_for_signal(dbg);
            brk_enable(bp);
        }else{
            /*if we are here then this`s caused by PTRACE_SINGLESTEP and maybe we going to trigger a breakpoint or maybe not*/
            possible_pc += 1;
            one_machine_code_flag = false;
            HASH_FIND_PTR(dbg-&gt;d_brks, &amp;possible_pc, bp);
            if(bp != NULL &amp;&amp; bp-&gt;b_enabled){
                brk_disable(bp);
                ptrace(PTRACE_SINGLESTEP, dbg-&gt;d_pid, NULL, NULL);
                wait_for_signal(dbg);
                brk_enable(bp);
            }else{
                ptrace(PTRACE_SINGLESTEP, dbg-&gt;d_pid, NULL, NULL);
                wait_for_signal(dbg);
            }   
        }
    }else{
        /*the previous instruction is a single machine code instruction and breakpoint*/
        possible_pc = get_pc(dbg);      /*check current pc*/
        one_machine_code_flag = false;
        HASH_FIND_PTR(dbg-&gt;d_brks, &amp;possible_pc, bp);
        if(bp != NULL &amp;&amp; bp-&gt;b_enabled){
            brk_disable(bp);
            ptrace(PTRACE_SINGLESTEP, dbg-&gt;d_pid, NULL, NULL);
            wait_for_signal(dbg);
            brk_enable(bp);
        }else{
            ptrace(PTRACE_SINGLESTEP, dbg-&gt;d_pid, NULL, NULL);
            wait_for_signal(dbg);            
        }

    }
    show_UI(dbg);
}
</code></pre>
<p>​    步过主要用在函数调用上，在使用步过时主要考虑以下几种情况：</p>
<ul>
<li>pc触发了需要步过的call指令上的断点，即pc执行了0xcc</li>
<li>pc即将步过的call指令上被插入了断点</li>
<li>其他就是单步情况</li>
</ul>
<p>这里步过一个call采用的方式是在call指令下一条指令下断点然后PTRACE_CONT。同样使用capstone计算call指令长度然后断下后面一条指令，这样需要考虑如果被step over的函数如果没有中断那么将触发call指令后面一条指令，<strong>那么INT3被执行还需让pc-1</strong></p>
<pre><code class="c">/**
 * This function invoked in 4 situation:
 * 1.Just work as step in
 * 2.jump over a call but has triggered an breakpoint(0xcc)
 * 3.jump over a call but no breakpoint in current call instruction
 * 4.jump over a call but there is 0xcc in current call instruction
 * we can show UI here
*/
void dbg_step_over(Debugger *dbg){
    uint64_t possible_pc_prev = get_pc(dbg) - 1;        /*if this is breakpoint int 3 executed*/
    uint64_t possible_pc_currn = possible_pc_prev + 1;   /*if current instruction is breakpoint*/
    Breakpoint *bp_prev = NULL;
    Breakpoint *bp_currn = NULL;
    uint64_t data;
    uint64_t next_addr;

    /*Maybe stoped for triggered a breakpoint*/
    /*previous instruction. Jump over a call but has triggered an breakpoint(0xcc)*/
    HASH_FIND_PTR(dbg-&gt;d_brks, &amp;possible_pc_prev, bp_prev);
    if(bp_prev != NULL &amp;&amp; bp_prev-&gt;b_enabled &amp;&amp; bp_prev-&gt;b_saved_data == 0xE8){     /*call`s op code is 0xE8*/
        /*call instruction has been triggered*/
        brk_disable(bp_prev);
        data = ptrace(PTRACE_PEEKDATA, dbg-&gt;d_pid, possible_pc_prev, NULL);
        csh handle = 0;
        cs_insn* insn;
        size_t count;
        int child_status;
        if (cs_open(CS_ARCH_X86, CS_MODE_64, &amp;handle)) {
            printf("[error]: Failed to initialize capstone engine!\n");
            exit(-1);
        }
        cs_disasm(handle, (unsigned char*)&amp;data, 8, possible_pc_prev, 1, &amp;insn);
        next_addr = possible_pc_prev + insn-&gt;size;
        dbg_set_breakpoint_at_address(dbg, next_addr);
        set_pc(dbg, possible_pc_prev);
        continue_execution(dbg);                        /*Probably trigger another breakpoint in the function. So we need to disable it when stop*/
        brk_enable(bp_prev);
        
        HASH_FIND_PTR(dbg-&gt;d_brks, &amp;next_addr, bp_prev);
        if(bp_prev != NULL &amp;&amp; bp_prev-&gt;b_enabled){
            brk_disable(bp_prev);                       /*disable it*/
        }
        if((get_pc(dbg) - 1) == next_addr){             /*we stoped maybe because of triggering int3 below the call. So after continue we should check executed int3*/
            set_pc(dbg, next_addr);          
        }
        cs_free(insn, 1);
        cs_close(&amp;handle);
        return;
    }else if(bp_prev != NULL &amp;&amp; bp_prev-&gt;b_enabled &amp;&amp; bp_prev-&gt;b_saved_data != 0xE8){
        /*normal instruction has been triggered. Just work as step in*/
        dbg_step_in(dbg);
        return;
    }

    /*stoped for PTRACE_SINGLESTEP*/
    /*current instruction. Jump over a call but there is 0xcc in current call instruction*/
    HASH_FIND_PTR(dbg-&gt;d_brks, &amp;possible_pc_currn, bp_currn);
    if(bp_currn != NULL &amp;&amp; bp_currn-&gt;b_enabled &amp;&amp; bp_currn-&gt;b_saved_data == 0xE8){
        /*current instruction is breakpoint and it`s a function invoking*/
        brk_disable(bp_currn);
        data = ptrace(PTRACE_PEEKDATA, dbg-&gt;d_pid, possible_pc_currn, NULL);
        csh handle = 0;
        cs_insn* insn;
        size_t count;
        int child_status;
        if (cs_open(CS_ARCH_X86, CS_MODE_64, &amp;handle)) {
            printf("[error]: Failed to initialize capstone engine!\n");
            exit(-1);
        }
        cs_disasm(handle, (unsigned char*)&amp;data, 8, possible_pc_currn, 1, &amp;insn);
        next_addr = possible_pc_currn + insn-&gt;size;
        dbg_set_breakpoint_at_address(dbg, next_addr);
        continue_execution(dbg);                        /*Probably trigger another breakpoint in the function. So we need to disable it when stop*/
        brk_enable(bp_currn);
        HASH_FIND_PTR(dbg-&gt;d_brks, &amp;next_addr, bp_currn);
        if(bp_currn != NULL &amp;&amp; bp_currn-&gt;b_enabled){
            brk_disable(bp_currn);                      /*disable it*/
        }
        if((get_pc(dbg) - 1) == next_addr){             /*we stoped maybe because of triggering int3 below the call. So after continue we should check executed int3*/
            set_pc(dbg, next_addr);          
        }
        cs_free(insn, 1);
        cs_close(&amp;handle);
        return;
    }else if(bp_currn != NULL &amp;&amp; bp_currn-&gt;b_enabled &amp;&amp; bp_currn-&gt;b_saved_data != 0xE8){
        /*current instruction is a breakpoint but not a calling so we could just step over. Just work as step in */
        dbg_step_in(dbg);
        show_UI(dbg);
        return;
    }

    
    /*not breakpoint in current invoking OR current normal instruction*/
    data = ptrace(PTRACE_PEEKDATA, dbg-&gt;d_pid, possible_pc_currn, NULL);
    if((data &amp; 0xff) == 0xE8){          
        /*Current instruction is a call.Set breakpoint at next instruction then continue*/
        csh handle = 0;
        cs_insn* insn;
        size_t count;
        int child_status;
        if (cs_open(CS_ARCH_X86, CS_MODE_64, &amp;handle)) {
            printf("[error]: Failed to initialize capstone engine!\n");
            exit(-1);
        }
        cs_disasm(handle, (unsigned char*)&amp;data, 8, possible_pc_currn, 1, &amp;insn);
        next_addr = possible_pc_currn + insn-&gt;size;
        dbg_set_breakpoint_at_address(dbg, next_addr);
        continue_execution(dbg);
        HASH_FIND_PTR(dbg-&gt;d_brks, &amp;next_addr, bp_currn);
        if(bp_currn != NULL &amp;&amp; bp_currn-&gt;b_enabled){
            brk_disable(bp_currn);
        }
        if((get_pc(dbg) - 1) == next_addr){             /*we stoped maybe because of triggering int3 below the call. So after continue we should check executed int3*/
            set_pc(dbg, next_addr);          
        }
        cs_free(insn, 1);
        cs_close(&amp;handle);
        return;
    }else
        dbg_step_in(dbg);           /*Current instruction is normal. Just work as step in*/
}
</code></pre>
<p>到这里已经具备基本功能了，可以在<code>dbg_handle_command</code>中添加命令支持：</p>
<pre><code class="c">void dbg_handle_command(Debugger *dbg, char *cmd){
    char *lcmd = strdup(cmd);
    char *argv[8] = { 0 };    
    char *command;

    argv[0] = strtok(lcmd, " ");
    for(int i = 1; i &lt; 8; i++){
        argv[i] = strtok(NULL, " ");
        if(argv[i] == NULL) break;
    }
    command = argv[0];
    if(command == NULL) return;
    if(is_prefix(command, "continue")){
        continue_execution(dbg);
    }else if(is_prefix(command, "quit")){
        exit_debugger(dbg);
    }else if(is_prefix(command, "break")){      /*format: break/b [addr]*/
        if(argv[1] == NULL)
            puts("command break expect an address!");
        else{
            dbg_set_breakpoint_at_address(dbg, strtoul(argv[1], NULL, 16));
        }
    }else if(is_prefix(command, "register")){   /*format: reg/r dump OR reg/r read/write [reg] value(hex)*/
        if(is_prefix(argv[1], "dump"))
            dbg_dump_all_regs(dbg);
        else if(is_prefix(argv[1], "read")){
            printf("value:\t0x%08lx\n", get_register_value(dbg-&gt;d_pid, get_register_from_name(argv[2])));
        }else if(is_prefix(argv[1], "write")){
            set_register_value(dbg-&gt;d_pid, get_register_from_name(argv[2]), strtoul(argv[3], NULL, 16));
        }
    }else if(is_prefix(command, "memory")){     /*memory/m read [addr] OR write [addr] [value]*/
        if(is_prefix(argv[1], "read")){
            printf("value:\t0x%08lx\n", dbg_read_memory(dbg, strtoul(argv[2], NULL, 16)));
        }
        else if(is_prefix(argv[1], "write")){
            printf("0x%08lx\t-&gt;\t", dbg_read_memory(dbg, strtoul(argv[2], NULL, 16)));
            dbg_write_memory(dbg, strtoul(argv[2], NULL, 16), strtoul(argv[3], NULL, 16));
            printf("0x%08lx\n", dbg_read_memory(dbg, strtoul(argv[3], NULL, 16)));
        }
    }else if(is_prefix(command, "step")){       /*step in OR step over*/
        if(is_prefix(argv[1], "in")){
            dbg_step_in(dbg);
        }else if(is_prefix(argv[1], "over")){
            dbg_step_over(dbg);
        }else{
            puts("Usage: step in / step over");
        }
    }
    else{
        fprintf(stderr, "Unkown command: %s.\n", command);
    }

    return free(lcmd);
}
</code></pre>
<p>这些是目前完成的功能，还有进程和线程支持还未完成</p>
<h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h2><p>​    一般debugger是要支持显示汇编的，这里实现的只是在每次单步和触发断点时打印寄存器信息和汇编。可以在每次单步或者触发断点时读取当前pc处的机器码借助capstone反汇编，<strong>但需要注意的是对于x86_64架构最长汇编指令为15字节但很少出现比较长的指令</strong>，所以实现汇编打印的时候每次仅读取16个字节进行反汇编并打印指令</p>
<pre><code class="c">/**
 * consider of the longest instruction is 15bytes(x86_64) then we read 16bytes everytime
 * and disassemble it with capstone engine
 * befor invoking show_asm the caller should make sure current pc is not a breakpoint
*/
void show_asm(Debugger *dbg){
    csh handle;
    cs_insn *insn;
    size_t count;
    uint8_t *code;
    size_t size = 15;
    uint64_t address;

    if(cs_open(CS_ARCH_X86, CS_MODE_64, &amp;handle)){
        printf("[error] cs_open(%d, %d, 0x%08lx)\n", CS_ARCH_X86, CS_MODE_64, &amp;handle);
        exit(-1);
    }
    code = calloc(1, 16);
    address = get_pc(dbg);
    *(uint64_t *)code = ptrace(PTRACE_PEEKDATA, dbg-&gt;d_pid, address, NULL);
    *((uint64_t *)code + 1) = ptrace(PTRACE_PEEKDATA, dbg-&gt;d_pid, address + 8, NULL);
    
    /*before we show assembly after pc we should consider if there is breakpoint in machine code behind*/
    Breakpoint *bp = NULL;
    for(uint64_t i = 0, tmp = address; i &lt; size; i++){
        HASH_FIND_PTR(dbg-&gt;d_brks, &amp;tmp, bp);
        if(bp != NULL &amp;&amp; bp-&gt;b_enabled){    
            *((uint8_t *)code + i) = bp-&gt;b_saved_data;
        }
        tmp++;
    }

    puts("-------------------------[Assembly]-------------------------");
    insn = cs_malloc(handle);
    while(cs_disasm_iter(handle, (const uint8_t **)&amp;code, &amp;size, &amp;address, insn)){
        if(size + insn-&gt;size == 15)
            printf("\e[96m0x%08lx:\t%s\t%s\t&lt;======RIP\e[0m\n", insn-&gt;address, insn-&gt;mnemonic, insn-&gt;op_str);
        else
            printf("0x%08lx:\t%s\t%s\n", insn-&gt;address, insn-&gt;mnemonic, insn-&gt;op_str);  
    }
    cs_free(insn, 1);
    cs_close(&amp;handle);
}
</code></pre>
<p>还有就是如果读取的15个字节中<strong>有断点(0xcc)那么反汇编结果是不准确的</strong>，因此先遍历是否存在断点并resotre原来的数据再进行反汇编。</p>
<h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><p>​    这里还没有实现多线程/进程调试的功能，<a target="_blank" rel="noopener" href="https://github.com/squarepants0/minidbg">源码</a>，但也算有个调试器的架子了</p>
<p><img src="https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20230223/image-20230210153302686.5bym3zeddbk0.png" alt="image-20230210153302686"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><p><a target="_blank" rel="noopener" href="https://github.com/kabeor/Capstone-Engine-Documentation/blob/master/Capstone-Engine%20Documentation.md">https://github.com/kabeor/Capstone-Engine-Documentation/blob/master/Capstone-Engine%20Documentation.md</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.tartanllama.xyz/writing-a-linux-debugger-setup/">Writing a Linux Debugger Part 1: Setup (tartanllama.xyz)</a>：作者讲解非常详细，还涉及源码调试功能，这里就没有加入该功能</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzA3NzYzODg1OA==&amp;mid=2648465474&amp;idx=2&amp;sn=52dfd43e8f376e1ff16b2f81c3c002a7&amp;scene=21#wechat_redirect">一文看懂 | GDB底层实现原理</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzA3NzYzODg1OA==&amp;mid=2648466708&amp;idx=1&amp;sn=fd765d1e3c958c194010f35728e46fb0&amp;scene=21#wechat_redirect">自己动手写一个GDB｜基本功能</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/squarepants0/minidbg">squarepants0/minidbg: Writing a minidbg on Linux with C (github.com)</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/troydhanson/uthash">troydhanson/uthash: C macros for hash tables and more (github.com)</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/antirez/linenoise">antirez/linenoise: A small self-contained alternative to readline and libedit (github.com)</a></p>
</li>
</ul>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls"
                data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
            <ul id="audio-list" style="display:none">
                
                
                <li title='0' data-url='/statics/chengdu.mp3'></li>
                
                    
            </ul>
            
                        
            
            
    <div id='gitalk-container' class="comment link"
        data-ae='false'
        data-ci=''
        data-cs=''
        data-r=''
        data-o=''
        data-a=''
        data-d=''
        data-p='https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token'
    >Comments</div>


            
            
        </div>
        <div class="sidebar">
            <div class="box animated fadeInRight">
                <div class="subbox">
                    <img src="https://cdn.staticaly.com/gh/L2ksy0d/image-host@master/20230112/yuanh.3xe42oas0b80.jpg" height=300 width=300></img>
                    <p>崎山松形</p>
                    <span>无所谓，袁神会出手</span>
                    <dl>
                        
                        
                            
                                <dd>
                                    <link rel="stylesheet" type="text/css" href="">
                                    <a href="function link() { [native code] }" target="_blank"><span
                                    class=" iconfont "></span></a>
                                </dd>
                            
                            
                            
                        
                    </dl>
                </div>
                <ul>
                    <li><a href="/">24 <p>Articles</p></a></li>
                    <li><a href="/categories">11 <p>Categories</p></a></li>
                    <li><a href="/tags">13 <p>Tags</p></a></li>
                </ul>
            </div>
            
            
            
            <div class="box sticky animated fadeInRight faster">
                <div id="toc" class="subbox">
                    <h4>Contents</h4>
                    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E8%B0%83%E8%AF%95%E5%99%A8"><span class="toc-number">1.</span> <span class="toc-text">实现一个简单的调试器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ptrace-%E5%8E%9F%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">ptrace 原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#PTRACE-TRACEME"><span class="toc-number">2.1.</span> <span class="toc-text">PTRACE_TRACEME</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PTRACE-SINGLESTEP"><span class="toc-number">2.2.</span> <span class="toc-text">PTRACE_SINGLESTEP</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Debugger-%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.</span> <span class="toc-text">Debugger 基本功能实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Parent"><span class="toc-number">3.1.</span> <span class="toc-text">Parent</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">3.2.</span> <span class="toc-text">读写寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E5%86%85%E5%AD%98"><span class="toc-number">3.2.1.</span> <span class="toc-text">读写内存</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%AD%E7%82%B9"><span class="toc-number">3.3.</span> <span class="toc-text">断点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E6%AD%A5"><span class="toc-number">3.4.</span> <span class="toc-text">单步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%87%E7%BC%96"><span class="toc-number">3.5.</span> <span class="toc-text">汇编</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%88%E6%9E%9C"><span class="toc-number">4.</span> <span class="toc-text">效果</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">5.</span> <span class="toc-text">参考</span></a></li></ol>
                </div>
            </div>
            
            
        </div>
    </div>
</div>

    </div>
</div>
    <div id="back-to-top" class="animated fadeIn faster">
        <div class="flow"></div>
        <span class="percentage animated fadeIn faster">0%</span>
        <span class="iconfont icon-top02 animated fadeIn faster"></span>
    </div>
</body>
<footer>
    <p class="copyright" id="copyright">
        &copy; 2023
        <span class="gradient-text">
            RainSec
        </span>.
        Powered by <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a>
        Theme
        <span class="gradient-text">
            <a href="https://github.com/TriDiamond/hexo-theme-obsidian" title="Obsidian" target="_blank" rel="noopener">Obsidian</a>
        </span>
        <small><a href="https://github.com/TriDiamond/hexo-theme-obsidian/blob/master/CHANGELOG.md" title="v1.4.9.3" target="_blank" rel="noopener">v1.4.9.3</a></small>
        
        
    </p>
</footer>

<script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script>
  MathJax.Hub.Config({
    "HTML-CSS": {
      preferredFont: "TeX",
      availableFonts: ["STIX", "TeX"],
      linebreaks: {
        automatic: true
      },
      EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
      inlineMath: [
        ["$", "$"],
        ["\\(", "\\)"]
      ],
      processEscapes: true,
      ignoreClass: "tex2jax_ignore|dno",
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      noUndefined: {
        attributes: {
          mathcolor: "red",
          mathbackground: "#FFEEEE",
          mathsize: "90%"
        }
      },
      Macros: {
        href: "{}"
      }
    },
    messageStyle: "none"
  });
</script>
<script>
  function initialMathJax() {
    MathJax.Hub.Queue(function () {
      var all = MathJax.Hub.getAllJax(),
        i;
      // console.log(all);
      for (i = 0; i < all.length; i += 1) {
        console.log(all[i].SourceElement().parentNode)
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  }

  function reprocessMathJax() {
    if (typeof MathJax !== 'undefined') {
      MathJax.Hub.Queue(["Typeset", MathJax.Hub]);
    }
  }
</script>


 
<link rel="stylesheet" href="//cdn.bootcss.com/gitalk/1.5.0/gitalk.min.css">
 
<script src="//cdn.bootcss.com/gitalk/1.5.0/gitalk.min.js"></script>
  
<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/obsidian.js"></script>
<script src="/js/jquery.truncate.js"></script>
<script src="/js/search.js"></script>
 
<script src="//cdn.bootcss.com/typed.js/2.0.10/typed.min.js"></script>
 
<script src="//cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script>
 
<script src="//cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>


<script src="https://cdn.bootcss.com/codemirror/5.48.4/codemirror.min.js"></script>
 
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/javascript/javascript.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/css/css.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/xml/xml.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/htmlmixed/htmlmixed.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/clike/clike.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/php/php.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/shell/shell.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/python/python.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/java/java.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/go/go.min.js"></script>
   
<script src="/js/busuanzi.min.js"></script>

<script>
  $(document).ready(function () {
    if ($('span[id^="busuanzi_"]').length) {
      initialBusuanzi();
    }
  });
</script>
 
<link rel="stylesheet" href="//cdn.bootcss.com/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="//cdn.bootcss.com/photoswipe/4.1.3/default-skin/default-skin.min.css">


<script src="//cdn.bootcss.com/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="//cdn.bootcss.com/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>
  

<script>
  function initialTyped() {
    var typedTextEl = $('.typed-text');
    if (typedTextEl && typedTextEl.length > 0) {
      var typed = new Typed('.typed-text', {
        strings: ['艺术家思维去思考问题，工匠创造精神去开发|', '致力于自动化渗透测试和漏洞挖掘'],
        typeSpeed: 90,
        loop: true,
        loopCount: Infinity,
        backSpeed: 20,
      });
    }
  }

  if ($('.article-header') && $('.article-header').length) {
    $(document).ready(function () {
      initialTyped();
    });
  }
</script>




<!-- 引用依赖 -->
<script>document.write(aplayerconf)</script>




</html>
